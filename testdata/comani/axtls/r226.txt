r226
Index: crypto/os_int.h
===================================================================
--- crypto/os_int.h	(revision 226)
+++ crypto/os_int.h	(nonexistent)
@@ -1,67 +0,0 @@
-/*
- * Copyright (c) 2012, Cameron Rich
- * 
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without 
- * modification, are permitted provided that the following conditions are met:
- *
- * * Redistributions of source code must retain the above copyright notice, 
- *   this list of conditions and the following disclaimer.
- * * Redistributions in binary form must reproduce the above copyright notice, 
- *   this list of conditions and the following disclaimer in the documentation 
- *   and/or other materials provided with the distribution.
- * * Neither the name of the axTLS project nor the names of its contributors 
- *   may be used to endorse or promote products derived from this software 
- *   without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/**
- * @file os_int.h
- *
- * Ensure a consistent bit size 
- */
-
-#ifndef HEADER_OS_INT_H
-#define HEADER_OS_INT_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#if defined(WIN32)
-typedef UINT8 uint8_t;
-typedef INT8 int8_t;
-typedef UINT16 uint16_t;
-typedef INT16 int16_t;
-typedef UINT32 uint32_t;
-typedef INT32 int32_t;
-typedef UINT64 uint64_t;
-typedef INT64 int64_t;
-#else   /* Not Win32 */
-
-#ifdef CONFIG_PLATFORM_SOLARIS
-#include <inttypes.h>
-#else
-#include <stdint.h>
-#endif /* Not Solaris */
-
-#endif /* Not Win32 */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif 
Index: crypto/crypto_misc.c
===================================================================
--- crypto/crypto_misc.c	(revision 226)
+++ crypto/crypto_misc.c	(revision 225)
@@ -1,367 +1,373 @@
 /*
  * Copyright (c) 2007, Cameron Rich
  * 
  * All rights reserved.
  * 
  * Redistribution and use in source and binary forms, with or without 
  * modification, are permitted provided that the following conditions are met:
  *
  * * Redistributions of source code must retain the above copyright notice, 
  *   this list of conditions and the following disclaimer.
  * * Redistributions in binary form must reproduce the above copyright notice, 
  *   this list of conditions and the following disclaimer in the documentation 
  *   and/or other materials provided with the distribution.
  * * Neither the name of the axTLS project nor the names of its contributors 
  *   may be used to endorse or promote products derived from this software 
  *   without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 /**
  * Some misc. routines to help things out
  */
 
 #include <stdlib.h>
 #include <string.h>
 #include <stdarg.h>
 #include <stdio.h>
 #include "os_port.h"
 #include "crypto_misc.h"
 #ifdef CONFIG_WIN32_USE_CRYPTO_LIB
 #include "wincrypt.h"
 #endif
 
 #ifndef WIN32
 static int rng_fd = -1;
 #elif defined(CONFIG_WIN32_USE_CRYPTO_LIB)
 static HCRYPTPROV gCryptProv;
 #endif
 
 #if (!defined(CONFIG_USE_DEV_URANDOM) && !defined(CONFIG_WIN32_USE_CRYPTO_LIB))
 /* change to processor registers as appropriate */
 #define ENTROPY_POOL_SIZE 32
 #define ENTROPY_COUNTER1 ((((uint64_t)tv.tv_sec)<<32) | tv.tv_usec)
 #define ENTROPY_COUNTER2 rand()
 static uint8_t entropy_pool[ENTROPY_POOL_SIZE];
 #endif
 
+static int rng_ref_count;
 const char * const unsupported_str = "Error: Feature not supported\n";
 
 #ifndef CONFIG_SSL_SKELETON_MODE
 /** 
  * Retrieve a file and put it into memory
  * @return The size of the file, or -1 on failure.
  */
 int get_file(const char *filename, uint8_t **buf)
 {
     int total_bytes = 0;
     int bytes_read = 0; 
     int filesize;
     FILE *stream = fopen(filename, "rb");
 
     if (stream == NULL)
     {
 #ifdef CONFIG_SSL_FULL_MODE         
         printf("file '%s' does not exist\n", filename); TTY_FLUSH();
 #endif
         return -1;
     }
 
     /* Win CE doesn't support stat() */
     fseek(stream, 0, SEEK_END);
     filesize = ftell(stream);
     *buf = (uint8_t *)malloc(filesize);
     fseek(stream, 0, SEEK_SET);
 
     do
     {
         bytes_read = fread(*buf+total_bytes, 1, filesize-total_bytes, stream);
         total_bytes += bytes_read;
     } while (total_bytes < filesize && bytes_read > 0);
     
     fclose(stream);
     return filesize;
 }
 #endif
 
 /**
  * Initialise the Random Number Generator engine.
  * - On Win32 use the platform SDK's crypto engine.
  * - On Linux use /dev/urandom
  * - If none of these work then use a custom RNG.
  */
-EXP_FUNC void STDCALL RNG_initialize()
+EXP_FUNC void STDCALL RNG_initialize(const uint8_t *seed_buf, int size)
 {
+    if (rng_ref_count == 0)
+    {
 #if !defined(WIN32) && defined(CONFIG_USE_DEV_URANDOM)
-    rng_fd = ax_open("/dev/urandom", O_RDONLY);
+        rng_fd = ax_open("/dev/urandom", O_RDONLY);
 #elif defined(WIN32) && defined(CONFIG_WIN32_USE_CRYPTO_LIB)
-    if (!CryptAcquireContext(&gCryptProv, 
-                      NULL, NULL, PROV_RSA_FULL, 0))
-    {
-        if (GetLastError() == NTE_BAD_KEYSET &&
-                !CryptAcquireContext(&gCryptProv, 
-                       NULL, 
-                       NULL, 
-                       PROV_RSA_FULL, 
-                       CRYPT_NEWKEYSET))
+        if (!CryptAcquireContext(&gCryptProv, 
+                          NULL, NULL, PROV_RSA_FULL, 0))
         {
-            printf("CryptoLib: %x\n", unsupported_str, GetLastError());
-            exit(1);
+            if (GetLastError() == NTE_BAD_KEYSET &&
+                    !CryptAcquireContext(&gCryptProv, 
+                           NULL, 
+                           NULL, 
+                           PROV_RSA_FULL, 
+                           CRYPT_NEWKEYSET))
+            {
+                printf("CryptoLib: %x\n", unsupported_str, GetLastError());
+                exit(1);
+            }
         }
-    }
-#else
-    /* start of with a stack to copy across */
-    int i;
-    memcpy(entropy_pool, &i, ENTROPY_POOL_SIZE);
-    srand(&i); 
-#endif
-}
+#else   
+        int i;
+        uint32_t seed_addr_val = (uint32_t)&seed_buf;
+        uint32_t *ep = (uint32_t *)entropy_pool;
 
-/**
- * If no /dev/urandom, then initialise the RNG with something interesting.
- */
-EXP_FUNC void STDCALL RNG_custom_init(const uint8_t *seed_buf, int size)
-{
-#if defined(WIN32) || defined(CONFIG_WIN32_USE_CRYPTO_LIB)
-    int i;
+        /* help start the entropy with the user's private key - this is 
+           a number that should be hard to find, due to the fact that it 
+           relies on knowing the private key */
+        memcpy(entropy_pool, seed_buf, ENTROPY_POOL_SIZE);
+        srand((long)entropy_pool); 
 
-    for (i = 0; i < ENTROPY_POOL_SIZE && i < size; i++)
-        entropy_pool[i] ^= seed_buf[i];
+        /* mix it up a little with a stack address */
+        for (i = 0; i < ENTROPY_POOL_SIZE/4; i++)
+            ep[i] ^= seed_addr_val;
+
 #endif
+    }
+
+    rng_ref_count++;
 }
 
 /**
  * Terminate the RNG engine.
  */
 EXP_FUNC void STDCALL RNG_terminate(void)
 {
+    if (--rng_ref_count == 0)
+    {
 #ifndef WIN32
-    close(rng_fd);
+        close(rng_fd);
 #elif defined(CONFIG_WIN32_USE_CRYPTO_LIB)
-    CryptReleaseContext(gCryptProv, 0);
+        CryptReleaseContext(gCryptProv, 0);
 #endif
+    }
 }
 
 /**
  * Set a series of bytes with a random number. Individual bytes can be 0
  */
 EXP_FUNC void STDCALL get_random(int num_rand_bytes, uint8_t *rand_data)
 {   
 #if !defined(WIN32) && defined(CONFIG_USE_DEV_URANDOM)
     /* use the Linux default */
     read(rng_fd, rand_data, num_rand_bytes);    /* read from /dev/urandom */
 #elif defined(WIN32) && defined(CONFIG_WIN32_USE_CRYPTO_LIB)
     /* use Microsoft Crypto Libraries */
     CryptGenRandom(gCryptProv, num_rand_bytes, rand_data);
 #else   /* nothing else to use, so use a custom RNG */
     /* The method we use when we've got nothing better. Use RC4, time 
        and a couple of random seeds to generate a random sequence */
     RC4_CTX rng_ctx;
     struct timeval tv;
     MD5_CTX rng_digest_ctx;
     uint8_t digest[MD5_SIZE];
     uint64_t *ep;
     int i;
 
     /* A proper implementation would use counters etc for entropy */
     gettimeofday(&tv, NULL);    
     ep = (uint64_t *)entropy_pool;
     ep[0] ^= ENTROPY_COUNTER1;
     ep[1] ^= ENTROPY_COUNTER2; 
 
     /* use a digested version of the entropy pool as a key */
     MD5_Init(&rng_digest_ctx);
     MD5_Update(&rng_digest_ctx, entropy_pool, ENTROPY_POOL_SIZE);
     MD5_Final(digest, &rng_digest_ctx);
 
     /* come up with the random sequence */
     RC4_setup(&rng_ctx, digest, MD5_SIZE); /* use as a key */
     memcpy(rand_data, entropy_pool, num_rand_bytes < ENTROPY_POOL_SIZE ?
 				num_rand_bytes : ENTROPY_POOL_SIZE);
     RC4_crypt(&rng_ctx, rand_data, rand_data, num_rand_bytes);
 
     /* move things along */
     for (i = ENTROPY_POOL_SIZE-1; i >= MD5_SIZE ; i--)
         entropy_pool[i] = entropy_pool[i-MD5_SIZE];
 
     /* insert the digest at the start of the entropy pool */
     memcpy(entropy_pool, digest, MD5_SIZE);
 #endif
 }
 
 /**
  * Set a series of bytes with a random number. Individual bytes are not zero.
  */
 void get_random_NZ(int num_rand_bytes, uint8_t *rand_data)
 {
     int i;
     get_random(num_rand_bytes, rand_data);
 
     for (i = 0; i < num_rand_bytes; i++)
     {
         while (rand_data[i] == 0)  /* can't be 0 */
             rand_data[i] = (uint8_t)(rand());
     }
 }
 
 /**
  * Some useful diagnostic routines
  */
 #if defined(CONFIG_SSL_FULL_MODE) || defined(CONFIG_DEBUG)
 int hex_finish;
 int hex_index;
 
 static void print_hex_init(int finish)
 {
     hex_finish = finish;
     hex_index = 0;
 }
 
 static void print_hex(uint8_t hex)
 {
     static int column;
 
     if (hex_index == 0)
     {
         column = 0;
     }
 
     printf("%02x ", hex);
     if (++column == 8)
     {
         printf(": ");
     }
     else if (column >= 16)
     {
         printf("\n");
         column = 0;
     }
 
     if (++hex_index >= hex_finish && column > 0)
     {
         printf("\n");
     }
 }
 
 /**
  * Spit out a blob of data for diagnostics. The data is is a nice column format
  * for easy reading.
  *
  * @param format   [in]    The string (with possible embedded format characters)
  * @param size     [in]    The number of numbers to print
  * @param data     [in]    The start of data to use
  * @param ...      [in]    Any additional arguments
  */
 EXP_FUNC void STDCALL print_blob(const char *format, 
         const uint8_t *data, int size, ...)
 {
     int i;
     char tmp[80];
     va_list(ap);
 
     va_start(ap, size);
     sprintf(tmp, "%s\n", format);
     vprintf(tmp, ap);
     print_hex_init(size);
     for (i = 0; i < size; i++)
     {
         print_hex(data[i]);
     }
 
     va_end(ap);
     TTY_FLUSH();
 }
 #elif defined(WIN32)
 /* VC6.0 doesn't handle variadic macros */
 EXP_FUNC void STDCALL print_blob(const char *format, const unsigned char *data,
         int size, ...) {}
 #endif
 
 #if defined(CONFIG_SSL_HAS_PEM) || defined(CONFIG_HTTP_HAS_AUTHORIZATION)
 /* base64 to binary lookup table */
 static const uint8_t map[128] =
 {
     255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
     255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
     255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
     255, 255, 255, 255, 255, 255, 255,  62, 255, 255, 255,  63,
     52,  53,  54,  55,  56,  57,  58,  59,  60,  61, 255, 255,
     255, 254, 255, 255, 255,   0,   1,   2,   3,   4,   5,   6,
     7,   8,   9,  10,  11,  12,  13,  14,  15,  16,  17,  18,
     19,  20,  21,  22,  23,  24,  25, 255, 255, 255, 255, 255,
     255,  26,  27,  28,  29,  30,  31,  32,  33,  34,  35,  36,
     37,  38,  39,  40,  41,  42,  43,  44,  45,  46,  47,  48,
     49,  50,  51, 255, 255, 255, 255, 255
 };
 
 EXP_FUNC int STDCALL base64_decode(const char *in, int len,
                     uint8_t *out, int *outlen)
 {
     int g, t, x, y, z;
     uint8_t c;
     int ret = -1;
 
     g = 3;
     for (x = y = z = t = 0; x < len; x++)
     {
         if ((c = map[in[x]&0x7F]) == 0xff)
             continue;
 
         if (c == 254)   /* this is the end... */
         {
             c = 0;
 
             if (--g < 0)
                 goto error;
         }
         else if (g != 3) /* only allow = at end */
             goto error;
 
         t = (t<<6) | c;
 
         if (++y == 4)
         {
             out[z++] = (uint8_t)((t>>16)&255);
 
             if (g > 1)
                 out[z++] = (uint8_t)((t>>8)&255);
 
             if (g > 2)
                 out[z++] = (uint8_t)(t&255);
 
             y = t = 0;
         }
 
         /* check that we don't go past the output buffer */
         if (z > *outlen) 
             goto error;
     }
 
     if (y != 0)
         goto error;
 
     *outlen = z;
     ret = 0;
 
 error:
 #ifdef CONFIG_SSL_FULL_MODE
     if (ret < 0)
         printf("Error: Invalid base64\n"); TTY_FLUSH();
 #endif
     TTY_FLUSH();
     return ret;
 
 }
 #endif
 
Index: crypto/crypto.h
===================================================================
--- crypto/crypto.h	(revision 226)
+++ crypto/crypto.h	(revision 225)
@@ -1,230 +1,229 @@
 /*
  * Copyright (c) 2007, Cameron Rich
  * 
  * All rights reserved.
  * 
  * Redistribution and use in source and binary forms, with or without 
  * modification, are permitted provided that the following conditions are met:
  *
  * * Redistributions of source code must retain the above copyright notice, 
  *   this list of conditions and the following disclaimer.
  * * Redistributions in binary form must reproduce the above copyright notice, 
  *   this list of conditions and the following disclaimer in the documentation 
  *   and/or other materials provided with the distribution.
  * * Neither the name of the axTLS project nor the names of its contributors 
  *   may be used to endorse or promote products derived from this software 
  *   without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 /**
  * @file crypto.h
  */
 
 #ifndef HEADER_CRYPTO_H
 #define HEADER_CRYPTO_H
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
 #include "config.h"
 #include "bigint_impl.h"
 #include "bigint.h"
 
 #ifndef STDCALL
 #define STDCALL
 #endif
 #ifndef EXP_FUNC
 #define EXP_FUNC
 #endif
 
 
 /* enable features based on a 'super-set' capbaility. */
 #if defined(CONFIG_SSL_FULL_MODE) 
 #define CONFIG_SSL_ENABLE_CLIENT
 #define CONFIG_SSL_CERT_VERIFICATION
 #elif defined(CONFIG_SSL_ENABLE_CLIENT)
 #define CONFIG_SSL_CERT_VERIFICATION
 #endif
 
 /**************************************************************************
  * AES declarations 
  **************************************************************************/
 
 #define AES_MAXROUNDS			14
 #define AES_BLOCKSIZE           16
 #define AES_IV_SIZE             16
 
 typedef struct aes_key_st 
 {
     uint16_t rounds;
     uint16_t key_size;
     uint32_t ks[(AES_MAXROUNDS+1)*8];
     uint8_t iv[AES_IV_SIZE];
 } AES_CTX;
 
 typedef enum
 {
     AES_MODE_128,
     AES_MODE_256
 } AES_MODE;
 
 void AES_set_key(AES_CTX *ctx, const uint8_t *key, 
         const uint8_t *iv, AES_MODE mode);
 void AES_cbc_encrypt(AES_CTX *ctx, const uint8_t *msg, 
         uint8_t *out, int length);
 void AES_cbc_decrypt(AES_CTX *ks, const uint8_t *in, uint8_t *out, int length);
 void AES_convert_key(AES_CTX *ctx);
 
 /**************************************************************************
  * RC4 declarations 
  **************************************************************************/
 
 typedef struct 
 {
     uint8_t x, y, m[256];
 } RC4_CTX;
 
 void RC4_setup(RC4_CTX *s, const uint8_t *key, int length);
 void RC4_crypt(RC4_CTX *s, const uint8_t *msg, uint8_t *data, int length);
 
 /**************************************************************************
  * SHA1 declarations 
  **************************************************************************/
 
 #define SHA1_SIZE   20
 
 /*
  *  This structure will hold context information for the SHA-1
  *  hashing operation
  */
 typedef struct 
 {
     uint32_t Intermediate_Hash[SHA1_SIZE/4]; /* Message Digest */
     uint32_t Length_Low;            /* Message length in bits */
     uint32_t Length_High;           /* Message length in bits */
     uint16_t Message_Block_Index;   /* Index into message block array   */
     uint8_t Message_Block[64];      /* 512-bit message blocks */
 } SHA1_CTX;
 
 void SHA1_Init(SHA1_CTX *);
 void SHA1_Update(SHA1_CTX *, const uint8_t * msg, int len);
 void SHA1_Final(uint8_t *digest, SHA1_CTX *);
 
 /**************************************************************************
  * MD2 declarations 
  **************************************************************************/
 
 #define MD2_SIZE 16
 
 typedef struct
 {
     unsigned char cksum[16];    /* checksum of the data block */
     unsigned char state[48];    /* intermediate digest state */
     unsigned char buffer[16];   /* data block being processed */
     int left;                   /* amount of data in buffer */
 } MD2_CTX;
 
 EXP_FUNC void STDCALL MD2_Init(MD2_CTX *ctx);
 EXP_FUNC void STDCALL MD2_Update(MD2_CTX *ctx, const uint8_t *input, int ilen);
 EXP_FUNC void STDCALL MD2_Final(uint8_t *digest, MD2_CTX *ctx);
 
 /**************************************************************************
  * MD5 declarations 
  **************************************************************************/
 
 #define MD5_SIZE    16
 
 typedef struct 
 {
   uint32_t state[4];        /* state (ABCD) */
   uint32_t count[2];        /* number of bits, modulo 2^64 (lsb first) */
   uint8_t buffer[64];       /* input buffer */
 } MD5_CTX;
 
 EXP_FUNC void STDCALL MD5_Init(MD5_CTX *);
 EXP_FUNC void STDCALL MD5_Update(MD5_CTX *, const uint8_t *msg, int len);
 EXP_FUNC void STDCALL MD5_Final(uint8_t *digest, MD5_CTX *);
 
 /**************************************************************************
  * HMAC declarations 
  **************************************************************************/
 void hmac_md5(const uint8_t *msg, int length, const uint8_t *key, 
         int key_len, uint8_t *digest);
 void hmac_sha1(const uint8_t *msg, int length, const uint8_t *key, 
         int key_len, uint8_t *digest);
 
 /**************************************************************************
  * RSA declarations 
  **************************************************************************/
 
 typedef struct 
 {
     bigint *m;              /* modulus */
     bigint *e;              /* public exponent */
     bigint *d;              /* private exponent */
 #ifdef CONFIG_BIGINT_CRT
     bigint *p;              /* p as in m = pq */
     bigint *q;              /* q as in m = pq */
     bigint *dP;             /* d mod (p-1) */
     bigint *dQ;             /* d mod (q-1) */
     bigint *qInv;           /* q^-1 mod p */
 #endif
     int num_octets;
     BI_CTX *bi_ctx;
 } RSA_CTX;
 
 void RSA_priv_key_new(RSA_CTX **rsa_ctx, 
         const uint8_t *modulus, int mod_len,
         const uint8_t *pub_exp, int pub_len,
         const uint8_t *priv_exp, int priv_len
 #ifdef CONFIG_BIGINT_CRT
       , const uint8_t *p, int p_len,
         const uint8_t *q, int q_len,
         const uint8_t *dP, int dP_len,
         const uint8_t *dQ, int dQ_len,
         const uint8_t *qInv, int qInv_len
 #endif
         );
 void RSA_pub_key_new(RSA_CTX **rsa_ctx, 
         const uint8_t *modulus, int mod_len,
         const uint8_t *pub_exp, int pub_len);
 void RSA_free(RSA_CTX *ctx);
 int RSA_decrypt(const RSA_CTX *ctx, const uint8_t *in_data, uint8_t *out_data,
         int is_decryption);
 bigint *RSA_private(const RSA_CTX *c, bigint *bi_msg);
 #if defined(CONFIG_SSL_CERT_VERIFICATION) || defined(CONFIG_SSL_GENERATE_X509_CERT)
 bigint *RSA_sign_verify(BI_CTX *ctx, const uint8_t *sig, int sig_len,
         bigint *modulus, bigint *pub_exp);
 bigint *RSA_public(const RSA_CTX * c, bigint *bi_msg);
 int RSA_encrypt(const RSA_CTX *ctx, const uint8_t *in_data, uint16_t in_len, 
         uint8_t *out_data, int is_signing);
 void RSA_print(const RSA_CTX *ctx);
 #endif
 
 /**************************************************************************
  * RNG declarations 
  **************************************************************************/
-EXP_FUNC void STDCALL RNG_initialize(void);
-EXP_FUNC void STDCALL RNG_custom_init(const uint8_t *seed_buf, int size);
+EXP_FUNC void STDCALL RNG_initialize(const uint8_t *seed_buf, int size);
 EXP_FUNC void STDCALL RNG_terminate(void);
 EXP_FUNC void STDCALL get_random(int num_rand_bytes, uint8_t *rand_data);
 void get_random_NZ(int num_rand_bytes, uint8_t *rand_data);
 
 #ifdef __cplusplus
 }
 #endif
 
 #endif 
Index: ssl/tls1.c
===================================================================
--- ssl/tls1.c	(revision 226)
+++ ssl/tls1.c	(revision 225)
@@ -1,2192 +1,2191 @@
 /*
  * Copyright (c) 2007, Cameron Rich
  * 
  * All rights reserved.
  * 
  * Redistribution and use in source and binary forms, with or without 
  * modification, are permitted provided that the following conditions are met:
  *
  * * Redistributions of source code must retain the above copyright notice, 
  *   this list of conditions and the following disclaimer.
  * * Redistributions in binary form must reproduce the above copyright notice, 
  *   this list of conditions and the following disclaimer in the documentation 
  *   and/or other materials provided with the distribution.
  * * Neither the name of the axTLS project nor the names of its contributors 
  *   may be used to endorse or promote products derived from this software 
  *   without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 /**
  * Common ssl/tlsv1 code to both the client and server implementations.
  */
 
 #include <string.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <stdarg.h>
 #include "os_port.h"
 #include "ssl.h"
 
 /* The session expiry time */
 #define SSL_EXPIRY_TIME     (CONFIG_SSL_EXPIRY_TIME*3600)
 
 static const uint8_t g_hello_request[] = { HS_HELLO_REQUEST, 0, 0, 0 };
 static const uint8_t g_chg_cipher_spec_pkt[] = { 1 };
 static const char * server_finished = "server finished";
 static const char * client_finished = "client finished";
 
 static int do_handshake(SSL *ssl, uint8_t *buf, int read_len);
 static int set_key_block(SSL *ssl, int is_write);
 static int verify_digest(SSL *ssl, int mode, const uint8_t *buf, int read_len);
 static void *crypt_new(SSL *ssl, uint8_t *key, uint8_t *iv, int is_decrypt);
 static int send_raw_packet(SSL *ssl, uint8_t protocol);
 
 /**
  * The server will pick the cipher based on the order that the order that the
  * ciphers are listed. This order is defined at compile time.
  */
 #ifdef CONFIG_SSL_SKELETON_MODE
 const uint8_t ssl_prot_prefs[NUM_PROTOCOLS] = 
 { SSL_RC4_128_SHA };
 #else
 static void session_free(SSL_SESSION *ssl_sessions[], int sess_index);
 
 const uint8_t ssl_prot_prefs[NUM_PROTOCOLS] = 
 #ifdef CONFIG_SSL_PROT_LOW                  /* low security, fast speed */
 { SSL_RC4_128_SHA, SSL_AES128_SHA, SSL_AES256_SHA, SSL_RC4_128_MD5 };
 #elif CONFIG_SSL_PROT_MEDIUM                /* medium security, medium speed */
 { SSL_AES128_SHA, SSL_AES256_SHA, SSL_RC4_128_SHA, SSL_RC4_128_MD5 };    
 #else /* CONFIG_SSL_PROT_HIGH */            /* high security, low speed */
 { SSL_AES256_SHA, SSL_AES128_SHA, SSL_RC4_128_SHA, SSL_RC4_128_MD5 };
 #endif
 #endif /* CONFIG_SSL_SKELETON_MODE */
 
 /**
  * The cipher map containing all the essentials for each cipher.
  */
 #ifdef CONFIG_SSL_SKELETON_MODE
 static const cipher_info_t cipher_info[NUM_PROTOCOLS] = 
 {
     {   /* RC4-SHA */
         SSL_RC4_128_SHA,                /* RC4-SHA */
         16,                             /* key size */
         0,                              /* iv size */ 
         2*(SHA1_SIZE+16),               /* key block size */
         0,                              /* no padding */
         SHA1_SIZE,                      /* digest size */
         hmac_sha1,                      /* hmac algorithm */
         (crypt_func)RC4_crypt,          /* encrypt */
         (crypt_func)RC4_crypt           /* decrypt */
     },
 };
 #else
 static const cipher_info_t cipher_info[NUM_PROTOCOLS] = 
 {
     {   /* AES128-SHA */
         SSL_AES128_SHA,                 /* AES128-SHA */
         16,                             /* key size */
         16,                             /* iv size */ 
         2*(SHA1_SIZE+16+16),            /* key block size */
         16,                             /* block padding size */
         SHA1_SIZE,                      /* digest size */
         hmac_sha1,                      /* hmac algorithm */
         (crypt_func)AES_cbc_encrypt,    /* encrypt */
         (crypt_func)AES_cbc_decrypt     /* decrypt */
     },
     {   /* AES256-SHA */
         SSL_AES256_SHA,                 /* AES256-SHA */
         32,                             /* key size */
         16,                             /* iv size */ 
         2*(SHA1_SIZE+32+16),            /* key block size */
         16,                             /* block padding size */
         SHA1_SIZE,                      /* digest size */
         hmac_sha1,                      /* hmac algorithm */
         (crypt_func)AES_cbc_encrypt,    /* encrypt */
         (crypt_func)AES_cbc_decrypt     /* decrypt */
     },       
     {   /* RC4-SHA */
         SSL_RC4_128_SHA,                /* RC4-SHA */
         16,                             /* key size */
         0,                              /* iv size */ 
         2*(SHA1_SIZE+16),               /* key block size */
         0,                              /* no padding */
         SHA1_SIZE,                      /* digest size */
         hmac_sha1,                      /* hmac algorithm */
         (crypt_func)RC4_crypt,          /* encrypt */
         (crypt_func)RC4_crypt           /* decrypt */
     },
     /*
      * This protocol is from SSLv2 days and is unlikely to be used - but was
      * useful for testing different possible digest algorithms.
      */
     {   /* RC4-MD5 */
         SSL_RC4_128_MD5,                /* RC4-MD5 */
         16,                             /* key size */
         0,                              /* iv size */ 
         2*(MD5_SIZE+16),                /* key block size */
         0,                              /* no padding */
         MD5_SIZE,                       /* digest size */
         hmac_md5,                       /* hmac algorithm */
         (crypt_func)RC4_crypt,          /* encrypt */
         (crypt_func)RC4_crypt           /* decrypt */
     },
 };
 #endif
 
 static void prf(const uint8_t *sec, int sec_len, uint8_t *seed, int seed_len,
         uint8_t *out, int olen);
 static const cipher_info_t *get_cipher_info(uint8_t cipher);
 static void increment_read_sequence(SSL *ssl);
 static void increment_write_sequence(SSL *ssl);
 static void add_hmac_digest(SSL *ssl, int snd, uint8_t *hmac_header,
         const uint8_t *buf, int buf_len, uint8_t *hmac_buf);
 
 /* win32 VC6.0 doesn't have variadic macros */
 #if defined(WIN32) && !defined(CONFIG_SSL_FULL_MODE)
 void DISPLAY_BYTES(SSL *ssl, const char *format, 
         const uint8_t *data, int size, ...) {}
 #endif
 
 /**
  * Establish a new client/server context.
  */
 EXP_FUNC SSL_CTX *STDCALL ssl_ctx_new(uint32_t options, int num_sessions)
 {
     SSL_CTX *ssl_ctx = (SSL_CTX *)calloc(1, sizeof (SSL_CTX));
     ssl_ctx->options = options;
-    RNG_initialize();
 
     if (load_key_certs(ssl_ctx) < 0)
     {
         free(ssl_ctx);  /* can't load our key/certificate pair, so die */
         return NULL;
     }
 
 #ifndef CONFIG_SSL_SKELETON_MODE
     ssl_ctx->num_sessions = num_sessions;
 #endif
 
     SSL_CTX_MUTEX_INIT(ssl_ctx->mutex);
 
 #ifndef CONFIG_SSL_SKELETON_MODE
     if (num_sessions)
     {
         ssl_ctx->ssl_sessions = (SSL_SESSION **)
                         calloc(1, num_sessions*sizeof(SSL_SESSION *));
     }
 #endif
 
     return ssl_ctx;
 }
 
 /*
  * Remove a client/server context.
  */
 EXP_FUNC void STDCALL ssl_ctx_free(SSL_CTX *ssl_ctx)
 {
     SSL *ssl;
     int i;
 
     if (ssl_ctx == NULL)
         return;
 
     ssl = ssl_ctx->head;
 
     /* clear out all the ssl entries */
     while (ssl)
     {
         SSL *next = ssl->next;
         ssl_free(ssl);
         ssl = next;
     }
 
 #ifndef CONFIG_SSL_SKELETON_MODE
     /* clear out all the sessions */
     for (i = 0; i < ssl_ctx->num_sessions; i++)
         session_free(ssl_ctx->ssl_sessions, i);
 
     free(ssl_ctx->ssl_sessions);
 #endif
 
     i = 0;
     while (i < CONFIG_SSL_MAX_CERTS && ssl_ctx->certs[i].buf)
     {
         free(ssl_ctx->certs[i].buf);
         ssl_ctx->certs[i++].buf = NULL;
     }
 
 #ifdef CONFIG_SSL_CERT_VERIFICATION
     remove_ca_certs(ssl_ctx->ca_cert_ctx);
 #endif
     ssl_ctx->chain_length = 0;
     SSL_CTX_MUTEX_DESTROY(ssl_ctx->mutex);
     RSA_free(ssl_ctx->rsa_ctx);
     RNG_terminate();
     free(ssl_ctx);
 }
 
 /*
  * Free any used resources used by this connection.
  */
 EXP_FUNC void STDCALL ssl_free(SSL *ssl)
 {
     SSL_CTX *ssl_ctx;
 
     if (ssl == NULL)        /* just ignore null pointers */
         return;
 
     /* only notify if we weren't notified first */
     /* spec says we must notify when we are dying */
     if (!IS_SET_SSL_FLAG(SSL_SENT_CLOSE_NOTIFY))
       send_alert(ssl, SSL_ALERT_CLOSE_NOTIFY);
 
     ssl_ctx = ssl->ssl_ctx;
 
     SSL_CTX_LOCK(ssl_ctx->mutex);
 
     /* adjust the server SSL list */
     if (ssl->prev)
         ssl->prev->next = ssl->next;
     else
         ssl_ctx->head = ssl->next;
 
     if (ssl->next)
         ssl->next->prev = ssl->prev;
     else
         ssl_ctx->tail = ssl->prev;
 
     SSL_CTX_UNLOCK(ssl_ctx->mutex);
 
     /* may already be free - but be sure */
     free(ssl->encrypt_ctx);
     free(ssl->decrypt_ctx);
     disposable_free(ssl);
 #ifdef CONFIG_SSL_CERT_VERIFICATION
     x509_free(ssl->x509_ctx);
 #endif
 
     free(ssl);
 }
 
 /*
  * Read the SSL connection and send any alerts for various errors.
  */
 EXP_FUNC int STDCALL ssl_read(SSL *ssl, uint8_t **in_data)
 {
     int ret = basic_read(ssl, in_data);
 
     /* check for return code so we can send an alert */
     if (ret < SSL_OK && ret != SSL_CLOSE_NOTIFY)
     {
         if (ret != SSL_ERROR_CONN_LOST)
         {
             send_alert(ssl, ret);
 #ifndef CONFIG_SSL_SKELETON_MODE
             /* something nasty happened, so get rid of this session */
             kill_ssl_session(ssl->ssl_ctx->ssl_sessions, ssl);
 #endif
         }
     }
 
     return ret;
 }
 
 /*
  * Write application data to the client
  */
 EXP_FUNC int STDCALL ssl_write(SSL *ssl, const uint8_t *out_data, int out_len)
 {
     int n = out_len, nw, i, tot = 0;
 
     /* maximum size of a TLS packet is around 16kB, so fragment */
     do 
     {
         nw = n;
 
         if (nw > RT_MAX_PLAIN_LENGTH)    /* fragment if necessary */
             nw = RT_MAX_PLAIN_LENGTH;
 
         if ((i = send_packet(ssl, PT_APP_PROTOCOL_DATA, 
                                             &out_data[tot], nw)) <= 0)
         {
             out_len = i;    /* an error */
             break;
         }
 
         tot += i;
         n -= i;
     } while (n > 0);
 
     return out_len;
 }
 
 /**
  * Add a certificate to the certificate chain.
  */
 int add_cert(SSL_CTX *ssl_ctx, const uint8_t *buf, int len)
 {
     int ret = SSL_ERROR_NO_CERT_DEFINED, i = 0;
     SSL_CERT *ssl_cert;
     X509_CTX *cert = NULL;
     int offset;
 
     while (ssl_ctx->certs[i].buf && i < CONFIG_SSL_MAX_CERTS) 
         i++;
 
     if (i == CONFIG_SSL_MAX_CERTS) /* too many certs */
     {
 #ifdef CONFIG_SSL_FULL_MODE
         printf("Error: maximum number of certs added (%d) - change of "
                 "compile-time configuration required\n",
                 CONFIG_SSL_MAX_CERTS);
 #endif
         goto error;
     }
 
     if ((ret = x509_new(buf, &offset, &cert)))
         goto error;
 
 #if defined (CONFIG_SSL_FULL_MODE)
     if (ssl_ctx->options & SSL_DISPLAY_CERTS)
         x509_print(cert, NULL);
 #endif
 
     ssl_cert = &ssl_ctx->certs[i];
     ssl_cert->size = len;
     ssl_cert->buf = (uint8_t *)malloc(len);
     memcpy(ssl_cert->buf, buf, len);
     ssl_ctx->chain_length++;
     len -= offset;
     ret = SSL_OK;           /* ok so far */
 
     /* recurse? */
     if (len > 0)
     {
         ret = add_cert(ssl_ctx, &buf[offset], len);
     }
 
 error:
     x509_free(cert);        /* don't need anymore */
     return ret;
 }
 
 #ifdef CONFIG_SSL_CERT_VERIFICATION
 /**
  * Add a certificate authority.
  */
 int add_cert_auth(SSL_CTX *ssl_ctx, const uint8_t *buf, int len)
 {
     int ret = SSL_OK; /* ignore errors for now */
     int i = 0;
     CA_CERT_CTX *ca_cert_ctx;
 
     if (ssl_ctx->ca_cert_ctx == NULL)
         ssl_ctx->ca_cert_ctx = (CA_CERT_CTX *)calloc(1, sizeof(CA_CERT_CTX));
 
     ca_cert_ctx = ssl_ctx->ca_cert_ctx;
 
     while (i < CONFIG_X509_MAX_CA_CERTS && ca_cert_ctx->cert[i]) 
         i++;
 
     while (len > 0)
     {
         int offset;
         if (i >= CONFIG_X509_MAX_CA_CERTS)
         {
 #ifdef CONFIG_SSL_FULL_MODE
             printf("Error: maximum number of CA certs added (%d) - change of "
                     "compile-time configuration required\n", 
                     CONFIG_X509_MAX_CA_CERTS);
 #endif
             break;
         }
 
 
         /* ignore the return code */
         if (x509_new(buf, &offset, &ca_cert_ctx->cert[i]) == X509_OK)
         {
 #if defined (CONFIG_SSL_FULL_MODE)
             if (ssl_ctx->options & SSL_DISPLAY_CERTS)
                 x509_print(ca_cert_ctx->cert[i], NULL);
 #endif
         }
 
         i++;
         len -= offset;
     }
 
     return ret;
 }
 
 /*
  * Retrieve an X.509 distinguished name component
  */
 EXP_FUNC const char * STDCALL ssl_get_cert_dn(const SSL *ssl, int component)
 {
     if (ssl->x509_ctx == NULL)
         return NULL;
 
     switch (component)
     {
         case SSL_X509_CERT_COMMON_NAME:
             return ssl->x509_ctx->cert_dn[X509_COMMON_NAME];
 
         case SSL_X509_CERT_ORGANIZATION:
             return ssl->x509_ctx->cert_dn[X509_ORGANIZATION];
 
         case SSL_X509_CERT_ORGANIZATIONAL_NAME:       
             return ssl->x509_ctx->cert_dn[X509_ORGANIZATIONAL_UNIT];
 
         case SSL_X509_CA_CERT_COMMON_NAME:
             return ssl->x509_ctx->ca_cert_dn[X509_COMMON_NAME];
 
         case SSL_X509_CA_CERT_ORGANIZATION:
             return ssl->x509_ctx->ca_cert_dn[X509_ORGANIZATION];
 
         case SSL_X509_CA_CERT_ORGANIZATIONAL_NAME:       
             return ssl->x509_ctx->ca_cert_dn[X509_ORGANIZATIONAL_UNIT];
 
         default:
             return NULL;
     }
 }
 
 /*
  * Retrieve a "Subject Alternative Name" from a v3 certificate
  */
 EXP_FUNC const char * STDCALL ssl_get_cert_subject_alt_dnsname(const SSL *ssl,
         int dnsindex)
 {
     int i;
 
     if (ssl->x509_ctx == NULL || ssl->x509_ctx->subject_alt_dnsnames == NULL)
         return NULL;
 
     for (i = 0; i < dnsindex; ++i)
     {
         if (ssl->x509_ctx->subject_alt_dnsnames[i] == NULL)
             return NULL;
     }
 
     return ssl->x509_ctx->subject_alt_dnsnames[dnsindex];
 }
 
 #endif /* CONFIG_SSL_CERT_VERIFICATION */
 
 /*
  * Find an ssl object based on the client's file descriptor.
  */
 EXP_FUNC SSL * STDCALL ssl_find(SSL_CTX *ssl_ctx, int client_fd)
 {
     SSL *ssl;
 
     SSL_CTX_LOCK(ssl_ctx->mutex);
     ssl = ssl_ctx->head;
 
     /* search through all the ssl entries */
     while (ssl)
     {
         if (ssl->client_fd == client_fd)
         {
             SSL_CTX_UNLOCK(ssl_ctx->mutex);
             return ssl;
         }
 
         ssl = ssl->next;
     }
 
     SSL_CTX_UNLOCK(ssl_ctx->mutex);
     return NULL;
 }
 
 /*
  * Force the client to perform its handshake again.
  */
 EXP_FUNC int STDCALL ssl_renegotiate(SSL *ssl)
 {
     int ret = SSL_OK;
 
     disposable_new(ssl);
 #ifdef CONFIG_SSL_ENABLE_CLIENT
     if (IS_SET_SSL_FLAG(SSL_IS_CLIENT))
     {
         ret = do_client_connect(ssl);
     }
     else
 #endif
     {
         send_packet(ssl, PT_HANDSHAKE_PROTOCOL, 
                 g_hello_request, sizeof(g_hello_request));
         SET_SSL_FLAG(SSL_NEED_RECORD);
     }
 
     return ret;
 }
 
 /**
  * @brief Get what we need for key info.
  * @param cipher    [in]    The cipher information we are after
  * @param key_size  [out]   The key size for the cipher
  * @param iv_size   [out]   The iv size for the cipher
  * @return  The amount of key information we need.
  */
 static const cipher_info_t *get_cipher_info(uint8_t cipher)
 {
     int i;
 
     for (i = 0; i < NUM_PROTOCOLS; i++)
     {
         if (cipher_info[i].cipher == cipher)
         {
             return &cipher_info[i];
         }
     }
 
     return NULL;  /* error */
 }
 
 /*
  * Get a new ssl context for a new connection.
  */
 SSL *ssl_new(SSL_CTX *ssl_ctx, int client_fd)
 {
     SSL *ssl = (SSL *)calloc(1, sizeof(SSL));
     ssl->ssl_ctx = ssl_ctx;
     ssl->need_bytes = SSL_RECORD_SIZE;      /* need a record */
     ssl->client_fd = client_fd;
     ssl->flag = SSL_NEED_RECORD;
     ssl->bm_data = ssl->bm_all_data+BM_RECORD_OFFSET; /* space at the start */
     ssl->hs_status = SSL_NOT_OK;            /* not connected */
 #ifdef CONFIG_ENABLE_VERIFICATION
     ssl->ca_cert_ctx = ssl_ctx->ca_cert_ctx;
 #endif
     disposable_new(ssl);
 
     /* a bit hacky but saves a few bytes of memory */
     ssl->flag |= ssl_ctx->options;
     SSL_CTX_LOCK(ssl_ctx->mutex);
 
     if (ssl_ctx->head == NULL)
     {
         ssl_ctx->head = ssl;
         ssl_ctx->tail = ssl;
     }
     else
     {
         ssl->prev = ssl_ctx->tail;
         ssl_ctx->tail->next = ssl;
         ssl_ctx->tail = ssl;
     }
 
     SSL_CTX_UNLOCK(ssl_ctx->mutex);
     return ssl;
 }
 
 /*
  * Add a private key to a context.
  */
 int add_private_key(SSL_CTX *ssl_ctx, SSLObjLoader *ssl_obj)
 {
     int ret = SSL_OK;
 
     /* get the private key details */
     if (asn1_get_private_key(ssl_obj->buf, ssl_obj->len, &ssl_ctx->rsa_ctx))
     {
         ret = SSL_ERROR_INVALID_KEY;
         goto error;
     }
 
 error:
     return ret;
 }
 
 /** 
  * Increment the read sequence number (as a 64 bit endian indepenent #)
  */     
 static void increment_read_sequence(SSL *ssl)
 {
     int i;
 
     for (i = 7; i >= 0; i--) 
     {       
         if (++ssl->read_sequence[i])
             break;
     }
 }
             
 /**
  * Increment the read sequence number (as a 64 bit endian indepenent #)
  */      
 static void increment_write_sequence(SSL *ssl)
 {        
     int i;                  
          
     for (i = 7; i >= 0; i--)
     {                       
         if (++ssl->write_sequence[i])
             break;
     }                       
 }
 
 /**
  * Work out the HMAC digest in a packet.
  */
 static void add_hmac_digest(SSL *ssl, int mode, uint8_t *hmac_header,
         const uint8_t *buf, int buf_len, uint8_t *hmac_buf)
 {
     int hmac_len = buf_len + 8 + SSL_RECORD_SIZE;
     uint8_t *t_buf = (uint8_t *)alloca(hmac_len+10);
 
     memcpy(t_buf, (mode == SSL_SERVER_WRITE || mode == SSL_CLIENT_WRITE) ? 
                     ssl->write_sequence : ssl->read_sequence, 8);
     memcpy(&t_buf[8], hmac_header, SSL_RECORD_SIZE);
     memcpy(&t_buf[8+SSL_RECORD_SIZE], buf, buf_len);
 
     ssl->cipher_info->hmac(t_buf, hmac_len, 
             (mode == SSL_SERVER_WRITE || mode == SSL_CLIENT_READ) ? 
                 ssl->server_mac : ssl->client_mac, 
             ssl->cipher_info->digest_size, hmac_buf);
 
 #if 0
     print_blob("record", ssl->hmac_tx, SSL_RECORD_SIZE);
     print_blob("buf", buf, buf_len);
     if (mode == SSL_SERVER_WRITE || mode == SSL_CLIENT_WRITE)
     {
         print_blob("write seq", ssl->write_sequence, 8);
     }
     else
     {
         print_blob("read seq", ssl->read_sequence, 8);
     }
 
     if (mode == SSL_SERVER_WRITE || mode == SSL_CLIENT_READ)
     {
         print_blob("server mac", 
                 ssl->server_mac, ssl->cipher_info->digest_size);
     }
     else
     {
         print_blob("client mac", 
                 ssl->client_mac, ssl->cipher_info->digest_size);
     }
     print_blob("hmac", hmac_buf, SHA1_SIZE);
 #endif
 }
 
 /**
  * Verify that the digest of a packet is correct.
  */
 static int verify_digest(SSL *ssl, int mode, const uint8_t *buf, int read_len)
 {   
     uint8_t hmac_buf[SHA1_SIZE];
     int hmac_offset;
    
     if (ssl->cipher_info->padding_size)
     {
         int last_blk_size = buf[read_len-1], i;
         hmac_offset = read_len-last_blk_size-ssl->cipher_info->digest_size-1;
 
         /* guard against a timing attack - make sure we do the digest */
         if (hmac_offset < 0)
         {
             hmac_offset = 0;
         }
         else
         {
             /* already looked at last byte */
             for (i = 1; i < last_blk_size; i++)
             {
                 if (buf[read_len-i] != last_blk_size)
                 {
                     hmac_offset = 0;
                     break;
                 }
             }
         }
     }
     else /* stream cipher */
     {
         hmac_offset = read_len - ssl->cipher_info->digest_size;
 
         if (hmac_offset < 0)
         {
             hmac_offset = 0;
         }
     }
 
     /* sanity check the offset */
     ssl->hmac_header[3] = hmac_offset >> 8;      /* insert size */
     ssl->hmac_header[4] = hmac_offset & 0xff;
     add_hmac_digest(ssl, mode, ssl->hmac_header, buf, hmac_offset, hmac_buf);
 
     if (memcmp(hmac_buf, &buf[hmac_offset], ssl->cipher_info->digest_size))
     {
         return SSL_ERROR_INVALID_HMAC;
     }
 
     return hmac_offset;
 }
 
 /**
  * Add a packet to the end of our sent and received packets, so that we may use
  * it to calculate the hash at the end.
  */
 void add_packet(SSL *ssl, const uint8_t *pkt, int len)
 {
     MD5_Update(&ssl->dc->md5_ctx, pkt, len);
     SHA1_Update(&ssl->dc->sha1_ctx, pkt, len);
 }
 
 /**
  * Work out the MD5 PRF.
  */
 static void p_hash_md5(const uint8_t *sec, int sec_len, 
         uint8_t *seed, int seed_len, uint8_t *out, int olen)
 {
     uint8_t a1[128];
 
     /* A(1) */
     hmac_md5(seed, seed_len, sec, sec_len, a1);
     memcpy(&a1[MD5_SIZE], seed, seed_len);
     hmac_md5(a1, MD5_SIZE+seed_len, sec, sec_len, out);
 
     while (olen > MD5_SIZE)
     {
         uint8_t a2[MD5_SIZE];
         out += MD5_SIZE;
         olen -= MD5_SIZE;
 
         /* A(N) */
         hmac_md5(a1, MD5_SIZE, sec, sec_len, a2);
         memcpy(a1, a2, MD5_SIZE);
 
         /* work out the actual hash */
         hmac_md5(a1, MD5_SIZE+seed_len, sec, sec_len, out);
     }
 }
 
 /**
  * Work out the SHA1 PRF.
  */
 static void p_hash_sha1(const uint8_t *sec, int sec_len, 
         uint8_t *seed, int seed_len, uint8_t *out, int olen)
 {
     uint8_t a1[128];
 
     /* A(1) */
     hmac_sha1(seed, seed_len, sec, sec_len, a1);
     memcpy(&a1[SHA1_SIZE], seed, seed_len);
     hmac_sha1(a1, SHA1_SIZE+seed_len, sec, sec_len, out);
 
     while (olen > SHA1_SIZE)
     {
         uint8_t a2[SHA1_SIZE];
         out += SHA1_SIZE;
         olen -= SHA1_SIZE;
 
         /* A(N) */
         hmac_sha1(a1, SHA1_SIZE, sec, sec_len, a2);
         memcpy(a1, a2, SHA1_SIZE);
 
         /* work out the actual hash */
         hmac_sha1(a1, SHA1_SIZE+seed_len, sec, sec_len, out);
     }
 }
 
 /**
  * Work out the PRF.
  */
 static void prf(const uint8_t *sec, int sec_len, uint8_t *seed, int seed_len,
         uint8_t *out, int olen)
 {
     int len, i;
     const uint8_t *S1, *S2;
     uint8_t xbuf[256]; /* needs to be > the amount of key data */
     uint8_t ybuf[256]; /* needs to be > the amount of key data */
 
     len = sec_len/2;
     S1 = sec;
     S2 = &sec[len];
     len += (sec_len & 1); /* add for odd, make longer */
 
     p_hash_md5(S1, len, seed, seed_len, xbuf, olen);
     p_hash_sha1(S2, len, seed, seed_len, ybuf, olen);
 
     for (i = 0; i < olen; i++)
         out[i] = xbuf[i] ^ ybuf[i];
 }
 
 /**
  * Generate a master secret based on the client/server random data and the
  * premaster secret.
  */
 void generate_master_secret(SSL *ssl, const uint8_t *premaster_secret)
 {
     uint8_t buf[128];   /* needs to be > 13+32+32 in size */
     strcpy((char *)buf, "master secret");
     memcpy(&buf[13], ssl->dc->client_random, SSL_RANDOM_SIZE);
     memcpy(&buf[45], ssl->dc->server_random, SSL_RANDOM_SIZE);
     prf(premaster_secret, SSL_SECRET_SIZE, buf, 77, ssl->dc->master_secret,
             SSL_SECRET_SIZE);
 }
 
 /**
  * Generate a 'random' blob of data used for the generation of keys.
  */
 static void generate_key_block(uint8_t *client_random, uint8_t *server_random,
         uint8_t *master_secret, uint8_t *key_block, int key_block_size)
 {
     uint8_t buf[128];
     strcpy((char *)buf, "key expansion");
     memcpy(&buf[13], server_random, SSL_RANDOM_SIZE);
     memcpy(&buf[45], client_random, SSL_RANDOM_SIZE);
     prf(master_secret, SSL_SECRET_SIZE, buf, 77, key_block, key_block_size);
 }
 
 /** 
  * Calculate the digest used in the finished message. This function also
  * doubles up as a certificate verify function.
  */
 void finished_digest(SSL *ssl, const char *label, uint8_t *digest)
 {
     uint8_t mac_buf[128]; 
     uint8_t *q = mac_buf;
     MD5_CTX md5_ctx = ssl->dc->md5_ctx;
     SHA1_CTX sha1_ctx = ssl->dc->sha1_ctx;
 
     if (label)
     {
         strcpy((char *)q, label);
         q += strlen(label);
     }
 
     MD5_Final(q, &md5_ctx);
     q += MD5_SIZE;
     
     SHA1_Final(q, &sha1_ctx);
     q += SHA1_SIZE;
 
     if (label)
     {
         prf(ssl->dc->master_secret, SSL_SECRET_SIZE, mac_buf, (int)(q-mac_buf),
             digest, SSL_FINISHED_HASH_SIZE);
     }
     else    /* for use in a certificate verify */
     {
         memcpy(digest, mac_buf, MD5_SIZE + SHA1_SIZE);
     }
 
 #if 0
     printf("label: %s\n", label);
     print_blob("master secret", ssl->dc->master_secret, 48);
     print_blob("mac_buf", mac_buf, q-mac_buf);
     print_blob("finished digest", digest, SSL_FINISHED_HASH_SIZE);
 #endif
 }   
     
 /**
  * Retrieve (and initialise) the context of a cipher.
  */
 static void *crypt_new(SSL *ssl, uint8_t *key, uint8_t *iv, int is_decrypt)
 {
     switch (ssl->cipher)
     {
 #ifndef CONFIG_SSL_SKELETON_MODE
         case SSL_AES128_SHA:
             {
                 AES_CTX *aes_ctx = (AES_CTX *)malloc(sizeof(AES_CTX));
                 AES_set_key(aes_ctx, key, iv, AES_MODE_128);
 
                 if (is_decrypt)
                 {
                     AES_convert_key(aes_ctx);
                 }
 
                 return (void *)aes_ctx;
             }
 
         case SSL_AES256_SHA:
             {
                 AES_CTX *aes_ctx = (AES_CTX *)malloc(sizeof(AES_CTX));
                 AES_set_key(aes_ctx, key, iv, AES_MODE_256);
 
                 if (is_decrypt)
                 {
                     AES_convert_key(aes_ctx);
                 }
 
                 return (void *)aes_ctx;
             }
 
         case SSL_RC4_128_MD5:
 #endif
         case SSL_RC4_128_SHA:
             {
                 RC4_CTX *rc4_ctx = (RC4_CTX *)malloc(sizeof(RC4_CTX));
                 RC4_setup(rc4_ctx, key, 16);
                 return (void *)rc4_ctx;
             }
     }
 
     return NULL;    /* its all gone wrong */
 }
 
 /**
  * Send a packet over the socket.
  */
 static int send_raw_packet(SSL *ssl, uint8_t protocol)
 {
     uint8_t *rec_buf = ssl->bm_all_data;
     int pkt_size = SSL_RECORD_SIZE+ssl->bm_index;
     int sent = 0;
     int ret = SSL_OK;
 
     rec_buf[0] = protocol;
     rec_buf[1] = 0x03;      /* version = 3.1 or higher */
     rec_buf[2] = ssl->version & 0x0f;
     rec_buf[3] = ssl->bm_index >> 8;
     rec_buf[4] = ssl->bm_index & 0xff;
 
     DISPLAY_BYTES(ssl, "sending %d bytes", ssl->bm_all_data, 
                              pkt_size, pkt_size);
 
     while (sent < pkt_size)
     {
         ret = SOCKET_WRITE(ssl->client_fd, 
                         &ssl->bm_all_data[sent], pkt_size-sent);
 
         if (ret >= 0)
             sent += ret;
         else
         {
 
 #ifdef WIN32
             if (GetLastError() != WSAEWOULDBLOCK)
 #else
             if (errno != EAGAIN && errno != EWOULDBLOCK)
 #endif
                 return SSL_ERROR_CONN_LOST;
         }
 
         /* keep going until the write buffer has some space */
         if (sent != pkt_size)
         {
             fd_set wfds;
             FD_ZERO(&wfds);
             FD_SET(ssl->client_fd, &wfds);
 
             /* block and wait for it */
             if (select(ssl->client_fd + 1, NULL, &wfds, NULL, NULL) < 0)
                 return SSL_ERROR_CONN_LOST;
         }
     }
 
     SET_SSL_FLAG(SSL_NEED_RECORD);  /* reset for next time */
     ssl->bm_index = 0;
 
     if (protocol != PT_APP_PROTOCOL_DATA)  
     {
         /* always return SSL_OK during handshake */   
         ret = SSL_OK;
     }
 
     return ret;
 }
 
 /**
  * Send an encrypted packet with padding bytes if necessary.
  */
 int send_packet(SSL *ssl, uint8_t protocol, const uint8_t *in, int length)
 {
     int ret, msg_length = 0;
 
     /* if our state is bad, don't bother */
     if (ssl->hs_status == SSL_ERROR_DEAD)
         return SSL_ERROR_CONN_LOST;
 
     if (in) /* has the buffer already been initialised? */
     {
         memcpy(ssl->bm_data, in, length);
     }
 
     msg_length += length;
 
     if (IS_SET_SSL_FLAG(SSL_TX_ENCRYPTED))
     {
         int mode = IS_SET_SSL_FLAG(SSL_IS_CLIENT) ? 
                             SSL_CLIENT_WRITE : SSL_SERVER_WRITE;
         uint8_t hmac_header[SSL_RECORD_SIZE] = 
         {
             protocol, 
             0x03, /* version = 3.1 or higher */
             ssl->version & 0x0f,
             msg_length >> 8,
             msg_length & 0xff 
         };
 
         if (protocol == PT_HANDSHAKE_PROTOCOL)
         {
             DISPLAY_STATE(ssl, 1, ssl->bm_data[0], 0);
 
             if (ssl->bm_data[0] != HS_HELLO_REQUEST)
             {
                 add_packet(ssl, ssl->bm_data, msg_length);
             }
         }
 
         /* add the packet digest */
         add_hmac_digest(ssl, mode, hmac_header, ssl->bm_data, msg_length, 
                                                 &ssl->bm_data[msg_length]);
         msg_length += ssl->cipher_info->digest_size;
 
         /* add padding? */
         if (ssl->cipher_info->padding_size)
         {
             int last_blk_size = msg_length%ssl->cipher_info->padding_size;
             int pad_bytes = ssl->cipher_info->padding_size - last_blk_size;
 
             /* ensure we always have at least 1 padding byte */
             if (pad_bytes == 0)
                 pad_bytes += ssl->cipher_info->padding_size;
 
             memset(&ssl->bm_data[msg_length], pad_bytes-1, pad_bytes);
             msg_length += pad_bytes;
         }
 
         DISPLAY_BYTES(ssl, "unencrypted write", ssl->bm_data, msg_length);
         increment_write_sequence(ssl);
 
         /* add the explicit IV for TLS1.1 */
         if (ssl->version >= SSL_PROTOCOL_VERSION1_1 &&
                         ssl->cipher_info->iv_size)
                         
         {
             uint8_t iv_size = ssl->cipher_info->iv_size;
             uint8_t *t_buf = alloca(msg_length + iv_size);
             memcpy(t_buf + iv_size, ssl->bm_data, msg_length);
             get_random(iv_size, t_buf);
             msg_length += iv_size;
             memcpy(ssl->bm_data, t_buf, msg_length);
         }
 
         /* now encrypt the packet */
         ssl->cipher_info->encrypt(ssl->encrypt_ctx, ssl->bm_data, 
                                             ssl->bm_data, msg_length);
     }
     else if (protocol == PT_HANDSHAKE_PROTOCOL)
     {
         DISPLAY_STATE(ssl, 1, ssl->bm_data[0], 0);
 
         if (ssl->bm_data[0] != HS_HELLO_REQUEST)
         {
             add_packet(ssl, ssl->bm_data, length);
         }
     }
 
     ssl->bm_index = msg_length;
     if ((ret = send_raw_packet(ssl, protocol)) <= 0)
         return ret;
 
     return length;  /* just return what we wanted to send */
 }
 
 /**
  * Work out the cipher keys we are going to use for this session based on the
  * master secret.
  */
 static int set_key_block(SSL *ssl, int is_write)
 {
     const cipher_info_t *ciph_info = get_cipher_info(ssl->cipher);
     uint8_t *q;
     uint8_t client_key[32], server_key[32]; /* big enough for AES256 */
     uint8_t client_iv[16], server_iv[16];   /* big enough for AES128/256 */
     int is_client = IS_SET_SSL_FLAG(SSL_IS_CLIENT);
 
     if (ciph_info == NULL)
         return -1;
 
     /* only do once in a handshake */
     if (ssl->dc->key_block == NULL)
     {
         ssl->dc->key_block = (uint8_t *)malloc(ciph_info->key_block_size);
 
 #if 0
         print_blob("client", ssl->dc->client_random, 32);
         print_blob("server", ssl->dc->server_random, 32);
         print_blob("master", ssl->dc->master_secret, SSL_SECRET_SIZE);
 #endif
         generate_key_block(ssl->dc->client_random, ssl->dc->server_random,
             ssl->dc->master_secret, ssl->dc->key_block, 
             ciph_info->key_block_size);
 #if 0
         print_blob("keyblock", ssl->key_block, ciph_info->key_block_size);
 #endif
     }
 
     q = ssl->dc->key_block;
 
     if ((is_client && is_write) || (!is_client && !is_write))
     {
         memcpy(ssl->client_mac, q, ciph_info->digest_size);
     }
 
     q += ciph_info->digest_size;
 
     if ((!is_client && is_write) || (is_client && !is_write))
     {
         memcpy(ssl->server_mac, q, ciph_info->digest_size);
     }
 
     q += ciph_info->digest_size;
     memcpy(client_key, q, ciph_info->key_size);
     q += ciph_info->key_size;
     memcpy(server_key, q, ciph_info->key_size);
     q += ciph_info->key_size;
 
 #ifndef CONFIG_SSL_SKELETON_MODE 
     if (ciph_info->iv_size)    /* RC4 has no IV, AES does */
     {
         memcpy(client_iv, q, ciph_info->iv_size);
         q += ciph_info->iv_size;
         memcpy(server_iv, q, ciph_info->iv_size);
         q += ciph_info->iv_size;
     }
 #endif
 
     free(is_write ? ssl->encrypt_ctx : ssl->decrypt_ctx);
 
     /* now initialise the ciphers */
     if (is_client)
     {
         finished_digest(ssl, server_finished, ssl->dc->final_finish_mac);
 
         if (is_write)
             ssl->encrypt_ctx = crypt_new(ssl, client_key, client_iv, 0);
         else
             ssl->decrypt_ctx = crypt_new(ssl, server_key, server_iv, 1);
     }
     else
     {
         finished_digest(ssl, client_finished, ssl->dc->final_finish_mac);
 
         if (is_write)
             ssl->encrypt_ctx = crypt_new(ssl, server_key, server_iv, 0);
         else
             ssl->decrypt_ctx = crypt_new(ssl, client_key, client_iv, 1);
     }
 
     ssl->cipher_info = ciph_info;
     return 0;
 }
 
 /**
  * Read the SSL connection.
  */
 int basic_read(SSL *ssl, uint8_t **in_data)
 {
     int ret = SSL_OK;
     int read_len, is_client = IS_SET_SSL_FLAG(SSL_IS_CLIENT);
     uint8_t *buf = ssl->bm_data;
 
     read_len = SOCKET_READ(ssl->client_fd, &buf[ssl->bm_read_index], 
                             ssl->need_bytes-ssl->got_bytes);
 
     if (read_len < 0) 
     {
 #ifdef WIN32
         if (GetLastError() == WSAEWOULDBLOCK)
 #else
         if (errno == EAGAIN || errno == EWOULDBLOCK)
 #endif
             return 0;
     }
 
     /* connection has gone, so die */
     if (read_len <= 0)
     {
         ret = SSL_ERROR_CONN_LOST;
         ssl->hs_status = SSL_ERROR_DEAD;  /* make sure it stays dead */
         goto error;
     }
 
     DISPLAY_BYTES(ssl, "received %d bytes", 
             &ssl->bm_data[ssl->bm_read_index], read_len, read_len);
 
     ssl->got_bytes += read_len;
     ssl->bm_read_index += read_len;
 
     /* haven't quite got what we want, so try again later */
     if (ssl->got_bytes < ssl->need_bytes)
         return SSL_OK;
 
     read_len = ssl->got_bytes;
     ssl->got_bytes = 0;
 
     if (IS_SET_SSL_FLAG(SSL_NEED_RECORD))
     {
         /* check for sslv2 "client hello" */
         if (buf[0] & 0x80 && buf[2] == 1)
         {
 #ifdef CONFIG_SSL_ENABLE_V23_HANDSHAKE
             uint8_t version = (buf[3] << 4) + buf[4];
             DISPLAY_BYTES(ssl, "ssl2 record", buf, 5);
 
             /* should be v3.1 (TLSv1) or better  */
             ssl->version = ssl->client_version = version;
 
             if (version > SSL_PROTOCOL_VERSION_MAX)
             {
                 /* use client's version */
                 ssl->version = SSL_PROTOCOL_VERSION_MAX;
             }
             else if (version < SSL_PROTOCOL_MIN_VERSION)  
             {
                 ret = SSL_ERROR_INVALID_VERSION;
                 ssl_display_error(ret);
                 return ret;
             }
 
             add_packet(ssl, &buf[2], 3);
             ret = process_sslv23_client_hello(ssl); 
 #else
             printf("Error: no SSLv23 handshaking allowed\n"); TTY_FLUSH();
             ret = SSL_ERROR_NOT_SUPPORTED;
 #endif
             goto error; /* not an error - just get out of here */
         }
 
         ssl->need_bytes = (buf[3] << 8) + buf[4];
 
         /* do we violate the spec with the message size?  */
         if (ssl->need_bytes > RT_MAX_PLAIN_LENGTH+RT_EXTRA-BM_RECORD_OFFSET)
         {
             ret = SSL_ERROR_INVALID_PROT_MSG;              
             goto error;
         }
 
         CLR_SSL_FLAG(SSL_NEED_RECORD);
         memcpy(ssl->hmac_header, buf, 3);       /* store for hmac */
         ssl->record_type = buf[0];
         goto error;                         /* no error, we're done */
     }
 
     /* for next time - just do it now in case of an error */
     SET_SSL_FLAG(SSL_NEED_RECORD);
     ssl->need_bytes = SSL_RECORD_SIZE;
 
     /* decrypt if we need to */
     if (IS_SET_SSL_FLAG(SSL_RX_ENCRYPTED))
     {
         ssl->cipher_info->decrypt(ssl->decrypt_ctx, buf, buf, read_len);
 
         if (ssl->version >= SSL_PROTOCOL_VERSION1_1 &&
                         ssl->cipher_info->iv_size)
         {
             buf += ssl->cipher_info->iv_size;
             read_len -= ssl->cipher_info->iv_size;
         }
 
         read_len = verify_digest(ssl, 
                 is_client ? SSL_CLIENT_READ : SSL_SERVER_READ, buf, read_len);
 
         /* does the hmac work? */
         if (read_len < 0)
         {
             ret = read_len;
             goto error;
         }
 
         DISPLAY_BYTES(ssl, "decrypted", buf, read_len);
         increment_read_sequence(ssl);
     }
 
     /* The main part of the SSL packet */
     switch (ssl->record_type)
     {
         case PT_HANDSHAKE_PROTOCOL:
             if (ssl->dc != NULL)
             {
                 ssl->dc->bm_proc_index = 0;
                 ret = do_handshake(ssl, buf, read_len);
             }
             else /* no client renegotiation allowed */
             {
                 ret = SSL_ERROR_NO_CLIENT_RENOG;              
                 goto error;
             }
             break;
 
         case PT_CHANGE_CIPHER_SPEC:
             if (ssl->next_state != HS_FINISHED)
             {
                 ret = SSL_ERROR_INVALID_HANDSHAKE;
                 goto error;
             }
 
             /* all encrypted from now on */
             SET_SSL_FLAG(SSL_RX_ENCRYPTED);
             if (set_key_block(ssl, 0) < 0)
             {
                 ret = SSL_ERROR_INVALID_HANDSHAKE;
                 goto error;
             }
             
             memset(ssl->read_sequence, 0, 8);
             break;
 
         case PT_APP_PROTOCOL_DATA:
             if (in_data)
             {
                 *in_data = buf;   /* point to the work buffer */
                 (*in_data)[read_len] = 0;  /* null terminate just in case */
             }
 
             ret = read_len;
             break;
 
         case PT_ALERT_PROTOCOL:
             /* return the alert # with alert bit set */
             if(buf[0] == SSL_ALERT_TYPE_WARNING &&
                buf[1] == SSL_ALERT_CLOSE_NOTIFY)
             {
               ret = SSL_CLOSE_NOTIFY;
               send_alert(ssl, SSL_ALERT_CLOSE_NOTIFY);
               SET_SSL_FLAG(SSL_SENT_CLOSE_NOTIFY);
             }
             else 
             {
                 ret = -buf[1]; 
                 DISPLAY_ALERT(ssl, buf[1]);
             }
 
             break;
 
         default:
             ret = SSL_ERROR_INVALID_PROT_MSG;
             break;
     }
 
 error:
     ssl->bm_read_index = 0;          /* reset to go again */
 
     if (ret < SSL_OK && in_data)/* if all wrong, then clear this buffer ptr */
         *in_data = NULL;
 
     return ret;
 }
 
 /**
  * Do some basic checking of data and then perform the appropriate handshaking.
  */
 static int do_handshake(SSL *ssl, uint8_t *buf, int read_len)
 {
     int hs_len = (buf[2]<<8) + buf[3];
     uint8_t handshake_type = buf[0];
     int ret = SSL_OK;
     int is_client = IS_SET_SSL_FLAG(SSL_IS_CLIENT);
 
     /* some integrity checking on the handshake */
     PARANOIA_CHECK(read_len-SSL_HS_HDR_SIZE, hs_len);
 
     if (handshake_type != ssl->next_state)
     {
         /* handle a special case on the client */
         if (!is_client || handshake_type != HS_CERT_REQ ||
                         ssl->next_state != HS_SERVER_HELLO_DONE)
         {
             ret = SSL_ERROR_INVALID_HANDSHAKE;
             goto error;
         }
     }
 
     hs_len += SSL_HS_HDR_SIZE;  /* adjust for when adding packets */
     ssl->bm_index = hs_len;     /* store the size and check later */
     DISPLAY_STATE(ssl, 0, handshake_type, 0);
 
     if (handshake_type != HS_CERT_VERIFY && handshake_type != HS_HELLO_REQUEST)
         add_packet(ssl, buf, hs_len); 
 
 #if defined(CONFIG_SSL_ENABLE_CLIENT)
     ret = is_client ? 
         do_clnt_handshake(ssl, handshake_type, buf, hs_len) :
         do_svr_handshake(ssl, handshake_type, buf, hs_len);
 #else
     ret = do_svr_handshake(ssl, handshake_type, buf, hs_len);
 #endif
 
     /* just use recursion to get the rest */
     if (hs_len < read_len && ret == SSL_OK)
         ret = do_handshake(ssl, &buf[hs_len], read_len-hs_len);
 
 error:
     return ret;
 }
 
 /**
  * Sends the change cipher spec message. We have just read a finished message
  * from the client.
  */
 int send_change_cipher_spec(SSL *ssl)
 {
     int ret = send_packet(ssl, PT_CHANGE_CIPHER_SPEC, 
             g_chg_cipher_spec_pkt, sizeof(g_chg_cipher_spec_pkt));
     SET_SSL_FLAG(SSL_TX_ENCRYPTED);
 
     if (ret >= 0 && set_key_block(ssl, 1) < 0)
         ret = SSL_ERROR_INVALID_HANDSHAKE;
 
     memset(ssl->write_sequence, 0, 8);
     return ret;
 }
 
 /**
  * Send a "finished" message
  */
 int send_finished(SSL *ssl)
 {
     uint8_t buf[SSL_FINISHED_HASH_SIZE+4] = {
         HS_FINISHED, 0, 0, SSL_FINISHED_HASH_SIZE };
 
     /* now add the finished digest mac (12 bytes) */
     finished_digest(ssl, 
         IS_SET_SSL_FLAG(SSL_IS_CLIENT) ?
                     client_finished : server_finished, &buf[4]);
 
 #ifndef CONFIG_SSL_SKELETON_MODE
     /* store in the session cache */
     if (!IS_SET_SSL_FLAG(SSL_SESSION_RESUME) && ssl->ssl_ctx->num_sessions)
     {
         memcpy(ssl->session->master_secret,
                 ssl->dc->master_secret, SSL_SECRET_SIZE);
     }
 #endif
 
     return send_packet(ssl, PT_HANDSHAKE_PROTOCOL,
                                 buf, SSL_FINISHED_HASH_SIZE+4);
 }
 
 /**
  * Send an alert message.
  * Return 1 if the alert was an "error".
  */
 int send_alert(SSL *ssl, int error_code)
 {
     int alert_num = 0;
     int is_warning = 0;
     uint8_t buf[2];
 
     /* Don't bother we're already dead */
     if (ssl->hs_status == SSL_ERROR_DEAD)
     {
         return SSL_ERROR_CONN_LOST;
     }
 
 #ifdef CONFIG_SSL_FULL_MODE
     if (IS_SET_SSL_FLAG(SSL_DISPLAY_STATES))
         ssl_display_error(error_code);
 #endif
 
     switch (error_code)
     {
         case SSL_ALERT_CLOSE_NOTIFY:
             is_warning = 1;
             alert_num = SSL_ALERT_CLOSE_NOTIFY;
             break;
 
         case SSL_ERROR_CONN_LOST:       /* don't send alert just yet */
             is_warning = 1;
             break;
 
         case SSL_ERROR_INVALID_HANDSHAKE:
         case SSL_ERROR_INVALID_PROT_MSG:
             alert_num = SSL_ALERT_HANDSHAKE_FAILURE;
             break;
 
         case SSL_ERROR_INVALID_HMAC:
         case SSL_ERROR_FINISHED_INVALID:
             alert_num = SSL_ALERT_BAD_RECORD_MAC;
             break;
 
         case SSL_ERROR_INVALID_VERSION:
             alert_num = SSL_ALERT_INVALID_VERSION;
             break;
 
         case SSL_ERROR_INVALID_SESSION:
         case SSL_ERROR_NO_CIPHER:
         case SSL_ERROR_INVALID_KEY:
             alert_num = SSL_ALERT_ILLEGAL_PARAMETER;
             break;
 
         case SSL_ERROR_BAD_CERTIFICATE:
             alert_num = SSL_ALERT_BAD_CERTIFICATE;
             break;
 
         case SSL_ERROR_NO_CLIENT_RENOG:
             alert_num = SSL_ALERT_NO_RENEGOTIATION;
             break;
 
         default:
             /* a catch-all for any badly verified certificates */
             alert_num = (error_code <= SSL_X509_OFFSET) ?  
                 SSL_ALERT_BAD_CERTIFICATE : SSL_ALERT_UNEXPECTED_MESSAGE;
             break;
     }
 
     buf[0] = is_warning ? 1 : 2;
     buf[1] = alert_num;
     send_packet(ssl, PT_ALERT_PROTOCOL, buf, sizeof(buf));
     DISPLAY_ALERT(ssl, alert_num);
     return is_warning ? 0 : 1;
 }
 
 /**
  * Process a client finished message.
  */
 int process_finished(SSL *ssl, uint8_t *buf, int hs_len)
 {
     int ret = SSL_OK;
     int is_client = IS_SET_SSL_FLAG(SSL_IS_CLIENT);
     int resume = IS_SET_SSL_FLAG(SSL_SESSION_RESUME);
 
     PARANOIA_CHECK(ssl->bm_index, SSL_FINISHED_HASH_SIZE+4);
 
     /* check that we all work before we continue */
     if (memcmp(ssl->dc->final_finish_mac, &buf[4], SSL_FINISHED_HASH_SIZE))
         return SSL_ERROR_FINISHED_INVALID;
 
     if ((!is_client && !resume) || (is_client && resume))
     {
         if ((ret = send_change_cipher_spec(ssl)) == SSL_OK)
             ret = send_finished(ssl);
     }
 
     /* if we ever renegotiate */
     ssl->next_state = is_client ? HS_HELLO_REQUEST : HS_CLIENT_HELLO;  
     ssl->hs_status = ret;  /* set the final handshake status */
 
 error:
     return ret;
 }
 
 /**
  * Send a certificate.
  */
 int send_certificate(SSL *ssl)
 {
     int i = 0;
     uint8_t *buf = ssl->bm_data;
     int offset = 7;
     int chain_length;
 
     buf[0] = HS_CERTIFICATE;
     buf[1] = 0;
     buf[4] = 0;
 
     while (i < ssl->ssl_ctx->chain_length)
     {
         SSL_CERT *cert = &ssl->ssl_ctx->certs[i];
         buf[offset++] = 0;        
         buf[offset++] = cert->size >> 8;        /* cert 1 length */
         buf[offset++] = cert->size & 0xff;
         memcpy(&buf[offset], cert->buf, cert->size);
         offset += cert->size;
         i++;
     }
 
     chain_length = offset - 7;
     buf[5] = chain_length >> 8;        /* cert chain length */
     buf[6] = chain_length & 0xff;
     chain_length += 3;
     buf[2] = chain_length >> 8;        /* handshake length */
     buf[3] = chain_length & 0xff;
     ssl->bm_index = offset;
     return send_packet(ssl, PT_HANDSHAKE_PROTOCOL, NULL, offset);
 }
 
 /**
  * Create a blob of memory that we'll get rid of once the handshake is
  * complete.
  */
 void disposable_new(SSL *ssl)
 {
     if (ssl->dc == NULL)
     {
         ssl->dc = (DISPOSABLE_CTX *)calloc(1, sizeof(DISPOSABLE_CTX));
         MD5_Init(&ssl->dc->md5_ctx);
         SHA1_Init(&ssl->dc->sha1_ctx);
     }
 }
 
 /**
  * Remove the temporary blob of memory.
  */
 void disposable_free(SSL *ssl)
 {
     if (ssl->dc)
     {
         free(ssl->dc->key_block);
         memset(ssl->dc, 0, sizeof(DISPOSABLE_CTX));
         free(ssl->dc);
         ssl->dc = NULL;
     }
 
 }
 
 #ifndef CONFIG_SSL_SKELETON_MODE     /* no session resumption in this mode */
 /**
  * Find if an existing session has the same session id. If so, use the
  * master secret from this session for session resumption.
  */
 SSL_SESSION *ssl_session_update(int max_sessions, SSL_SESSION *ssl_sessions[], 
         SSL *ssl, const uint8_t *session_id)
 {
     time_t tm = time(NULL);
     time_t oldest_sess_time = tm;
     SSL_SESSION *oldest_sess = NULL;
     int i;
 
     /* no sessions? Then bail */
     if (max_sessions == 0)
         return NULL;
 
     SSL_CTX_LOCK(ssl->ssl_ctx->mutex);
     if (session_id)
     {
         for (i = 0; i < max_sessions; i++)
         {
             if (ssl_sessions[i])
             {
                 /* kill off any expired sessions (including those in 
                    the future) */
                 if ((tm > ssl_sessions[i]->conn_time + SSL_EXPIRY_TIME) ||
                             (tm < ssl_sessions[i]->conn_time))
                 {
                     session_free(ssl_sessions, i);
                     continue;
                 }
 
                 /* if the session id matches, it must still be less than 
                    the expiry time */
                 if (memcmp(ssl_sessions[i]->session_id, session_id,
                                                 SSL_SESSION_ID_SIZE) == 0)
                 {
                     ssl->session_index = i;
                     memcpy(ssl->dc->master_secret, 
                             ssl_sessions[i]->master_secret, SSL_SECRET_SIZE);
                     SET_SSL_FLAG(SSL_SESSION_RESUME);
                     SSL_CTX_UNLOCK(ssl->ssl_ctx->mutex);
                     return ssl_sessions[i];  /* a session was found */
                 }
             }
         }
     }
 
     /* If we've got here, no matching session was found - so create one */
     for (i = 0; i < max_sessions; i++)
     {
         if (ssl_sessions[i] == NULL)
         {
             /* perfect, this will do */
             ssl_sessions[i] = (SSL_SESSION *)calloc(1, sizeof(SSL_SESSION));
             ssl_sessions[i]->conn_time = tm;
             ssl->session_index = i;
             SSL_CTX_UNLOCK(ssl->ssl_ctx->mutex);
             return ssl_sessions[i]; /* return the session object */
         }
         else if (ssl_sessions[i]->conn_time <= oldest_sess_time)
         {
             /* find the oldest session */
             oldest_sess_time = ssl_sessions[i]->conn_time;
             oldest_sess = ssl_sessions[i];
             ssl->session_index = i;
         }
     }
 
     /* ok, we've used up all of our sessions. So blow the oldest session away */
     oldest_sess->conn_time = tm;
     memset(oldest_sess->session_id, 0, sizeof(SSL_SESSION_ID_SIZE));
     memset(oldest_sess->master_secret, 0, sizeof(SSL_SECRET_SIZE));
     SSL_CTX_UNLOCK(ssl->ssl_ctx->mutex);
     return oldest_sess;
 }
 
 /**
  * Free an existing session.
  */
 static void session_free(SSL_SESSION *ssl_sessions[], int sess_index)
 {
     if (ssl_sessions[sess_index])
     {
         free(ssl_sessions[sess_index]);
         ssl_sessions[sess_index] = NULL;
     }
 }
 
 /**
  * This ssl object doesn't want this session anymore.
  */
 void kill_ssl_session(SSL_SESSION **ssl_sessions, SSL *ssl)
 {
     SSL_CTX_LOCK(ssl->ssl_ctx->mutex);
 
     if (ssl->ssl_ctx->num_sessions)
     {
         session_free(ssl_sessions, ssl->session_index);
         ssl->session = NULL;
     }
 
     SSL_CTX_UNLOCK(ssl->ssl_ctx->mutex);
 }
 #endif /* CONFIG_SSL_SKELETON_MODE */
 
 /*
  * Get the session id for a handshake. This will be a 32 byte sequence.
  */
 EXP_FUNC const uint8_t * STDCALL ssl_get_session_id(const SSL *ssl)
 {
     return ssl->session_id;
 }
 
 /*
  * Get the session id size for a handshake. 
  */
 EXP_FUNC uint8_t STDCALL ssl_get_session_id_size(const SSL *ssl)
 {
     return ssl->sess_id_size;
 }
 
 /*
  * Return the cipher id (in the SSL form).
  */
 EXP_FUNC uint8_t STDCALL ssl_get_cipher_id(const SSL *ssl)
 {
     return ssl->cipher;
 }
 
 /*
  * Return the status of the handshake.
  */
 EXP_FUNC int STDCALL ssl_handshake_status(const SSL *ssl)
 {
     return ssl->hs_status;
 }
 
 /*
  * Retrieve various parameters about the SSL engine.
  */
 EXP_FUNC int STDCALL ssl_get_config(int offset)
 {
     switch (offset)
     {
         /* return the appropriate build mode */
         case SSL_BUILD_MODE:
 #if defined(CONFIG_SSL_FULL_MODE)
             return SSL_BUILD_FULL_MODE;
 #elif defined(CONFIG_SSL_ENABLE_CLIENT)
             return SSL_BUILD_ENABLE_CLIENT;
 #elif defined(CONFIG_ENABLE_VERIFICATION)
             return SSL_BUILD_ENABLE_VERIFICATION;
 #elif defined(CONFIG_SSL_SERVER_ONLY )
             return SSL_BUILD_SERVER_ONLY;
 #else 
             return SSL_BUILD_SKELETON_MODE;
 #endif
 
         case SSL_MAX_CERT_CFG_OFFSET:
             return CONFIG_SSL_MAX_CERTS;
 
 #ifdef CONFIG_SSL_CERT_VERIFICATION
         case SSL_MAX_CA_CERT_CFG_OFFSET:
             return CONFIG_X509_MAX_CA_CERTS;
 #endif
 #ifdef CONFIG_SSL_HAS_PEM
         case SSL_HAS_PEM:
             return 1;
 #endif
         default:
             return 0;
     }
 }
 
 #ifdef CONFIG_SSL_CERT_VERIFICATION
 /**
  * Authenticate a received certificate.
  */
 EXP_FUNC int STDCALL ssl_verify_cert(const SSL *ssl)
 {
     int ret;
     SSL_CTX_LOCK(ssl->ssl_ctx->mutex);
     ret = x509_verify(ssl->ssl_ctx->ca_cert_ctx, ssl->x509_ctx);
     SSL_CTX_UNLOCK(ssl->ssl_ctx->mutex);
 
     if (ret)        /* modify into an SSL error type */
     {
         ret = SSL_X509_ERROR(ret);
     }
 
     return ret;
 }
 
 /**
  * Process a certificate message.
  */
 int process_certificate(SSL *ssl, X509_CTX **x509_ctx)
 {
     int ret = SSL_OK;
     uint8_t *buf = &ssl->bm_data[ssl->dc->bm_proc_index];
     int pkt_size = ssl->bm_index;
     int cert_size, offset = 5;
     int total_cert_size = (buf[offset]<<8) + buf[offset+1];
     int is_client = IS_SET_SSL_FLAG(SSL_IS_CLIENT);
     X509_CTX **chain = x509_ctx;
     offset += 2;
 
     PARANOIA_CHECK(total_cert_size, offset);
 
     while (offset < total_cert_size)
     {
         offset++;       /* skip empty char */
         cert_size = (buf[offset]<<8) + buf[offset+1];
         offset += 2;
         
         if (x509_new(&buf[offset], NULL, chain))
         {
             ret = SSL_ERROR_BAD_CERTIFICATE;
             goto error;
         }
 
         chain = &((*chain)->next);
         offset += cert_size;
     }
 
     PARANOIA_CHECK(pkt_size, offset);
 
     /* if we are client we can do the verify now or later */
     if (is_client && !IS_SET_SSL_FLAG(SSL_SERVER_VERIFY_LATER))
     {
         ret = ssl_verify_cert(ssl);
     }
 
     ssl->next_state = is_client ? HS_SERVER_HELLO_DONE : HS_CLIENT_KEY_XCHG;
     ssl->dc->bm_proc_index += offset;
 error:
     return ret;
 }
 
 #endif /* CONFIG_SSL_CERT_VERIFICATION */
 
 /**
  * Debugging routine to display SSL handshaking stuff.
  */
 #ifdef CONFIG_SSL_FULL_MODE
 /**
  * Debugging routine to display SSL states.
  */
 void DISPLAY_STATE(SSL *ssl, int is_send, uint8_t state, int not_ok)
 {
     const char *str;
 
     if (!IS_SET_SSL_FLAG(SSL_DISPLAY_STATES))
         return;
 
     printf(not_ok ? "Error - invalid State:\t" : "State:\t");
     printf(is_send ? "sending " : "receiving ");
 
     switch (state)
     {
         case HS_HELLO_REQUEST:
             str = "Hello Request (0)";
             break;
 
         case HS_CLIENT_HELLO:
             str = "Client Hello (1)";
             break;
 
         case HS_SERVER_HELLO:
             str = "Server Hello (2)";
             break;
 
         case HS_CERTIFICATE:
             str = "Certificate (11)";
             break;
 
         case HS_SERVER_KEY_XCHG:
             str = "Certificate Request (12)";
             break;
 
         case HS_CERT_REQ:
             str = "Certificate Request (13)";
             break;
 
         case HS_SERVER_HELLO_DONE:
             str = "Server Hello Done (14)";
             break;
 
         case HS_CERT_VERIFY:
             str = "Certificate Verify (15)";
             break;
 
         case HS_CLIENT_KEY_XCHG:
             str = "Client Key Exchange (16)";
             break;
 
         case HS_FINISHED:
             str = "Finished (16)";
             break;
 
         default:
             str = "Error (Unknown)";
             
             break;
     }
 
     printf("%s\n", str);
     TTY_FLUSH();
 }
 
 /**
  * Debugging routine to display RSA objects
  */
 void DISPLAY_RSA(SSL *ssl, const RSA_CTX *rsa_ctx)
 {
     if (!IS_SET_SSL_FLAG(SSL_DISPLAY_RSA))
         return;
 
     RSA_print(rsa_ctx);
     TTY_FLUSH();
 }
 
 /**
  * Debugging routine to display SSL handshaking bytes.
  */
 void DISPLAY_BYTES(SSL *ssl, const char *format, 
         const uint8_t *data, int size, ...)
 {
     va_list(ap);
 
     if (!IS_SET_SSL_FLAG(SSL_DISPLAY_BYTES))
         return;
 
     va_start(ap, size);
     print_blob(format, data, size, va_arg(ap, char *));
     va_end(ap);
     TTY_FLUSH();
 }
 
 /**
  * Debugging routine to display SSL handshaking errors.
  */
 EXP_FUNC void STDCALL ssl_display_error(int error_code)
 {
     if (error_code == SSL_OK)
         return;
 
     printf("Error: ");
 
     /* X509 error? */
     if (error_code < SSL_X509_OFFSET)
     {
         printf("%s\n", x509_display_error(error_code - SSL_X509_OFFSET));
         return;
     }
 
     /* SSL alert error code */
     if (error_code > SSL_ERROR_CONN_LOST)
     {
         printf("SSL error %d\n", -error_code);
         return;
     }
 
     switch (error_code)
     {
         case SSL_ERROR_DEAD:
             printf("connection dead");
             break;
 
         case SSL_ERROR_INVALID_HANDSHAKE:
             printf("invalid handshake");
             break;
 
         case SSL_ERROR_INVALID_PROT_MSG:
             printf("invalid protocol message");
             break;
 
         case SSL_ERROR_INVALID_HMAC:
             printf("invalid mac");
             break;
 
         case SSL_ERROR_INVALID_VERSION:
             printf("invalid version");
             break;
 
         case SSL_ERROR_INVALID_SESSION:
             printf("invalid session");
             break;
 
         case SSL_ERROR_NO_CIPHER:
             printf("no cipher");
             break;
 
         case SSL_ERROR_CONN_LOST:
             printf("connection lost");
             break;
 
         case SSL_ERROR_BAD_CERTIFICATE:
             printf("bad certificate");
             break;
 
         case SSL_ERROR_INVALID_KEY:
             printf("invalid key");
             break;
 
         case SSL_ERROR_FINISHED_INVALID:
             printf("finished invalid");
             break;
 
         case SSL_ERROR_NO_CERT_DEFINED:
             printf("no certificate defined");
             break;
 
         case SSL_ERROR_NO_CLIENT_RENOG:
             printf("client renegotiation not supported");
             break;
             
         case SSL_ERROR_NOT_SUPPORTED:
             printf("Option not supported");
             break;
 
         default:
             printf("undefined as yet - %d", error_code);
             break;
     }
 
     printf("\n");
     TTY_FLUSH();
 }
 
 /**
  * Debugging routine to display alerts.
  */
 void DISPLAY_ALERT(SSL *ssl, int alert)
 {
     if (!IS_SET_SSL_FLAG(SSL_DISPLAY_STATES))
         return;
 
     printf("Alert: ");
 
     switch (alert)
     {
         case SSL_ALERT_CLOSE_NOTIFY:
             printf("close notify");
             break;
 
         case SSL_ALERT_INVALID_VERSION:
             printf("invalid version");
             break;
 
         case SSL_ALERT_BAD_CERTIFICATE:
             printf("bad certificate");
             break;
 
         case SSL_ALERT_UNEXPECTED_MESSAGE:
             printf("unexpected message");
             break;
 
         case SSL_ALERT_BAD_RECORD_MAC:
             printf("bad record mac");
             break;
 
         case SSL_ALERT_HANDSHAKE_FAILURE:
             printf("handshake failure");
             break;
 
         case SSL_ALERT_ILLEGAL_PARAMETER:
             printf("illegal parameter");
             break;
 
         case SSL_ALERT_DECODE_ERROR:
             printf("decode error");
             break;
 
         case SSL_ALERT_DECRYPT_ERROR:
             printf("decrypt error");
             break;
 
         case SSL_ALERT_NO_RENEGOTIATION:
             printf("no renegotiation");
             break;
 
         default:
             printf("alert - (unknown %d)", alert);
             break;
     }
 
     printf("\n");
     TTY_FLUSH();
 }
 
 #endif /* CONFIG_SSL_FULL_MODE */
 
 /**
  * Return the version of this library.
  */
 EXP_FUNC const char  * STDCALL ssl_version()
 {
     static const char * axtls_version = AXTLS_VERSION;
     return axtls_version;
 }
 
 /**
  * Enable the various language bindings to work regardless of the
  * configuration - they just return an error statement and a bad return code.
  */
 #if !defined(CONFIG_SSL_FULL_MODE)
 EXP_FUNC void STDCALL ssl_display_error(int error_code) {}
 #endif
 
 #ifdef CONFIG_BINDINGS
 #if !defined(CONFIG_SSL_ENABLE_CLIENT)
 EXP_FUNC SSL * STDCALL ssl_client_new(SSL_CTX *ssl_ctx, int client_fd, const
         uint8_t *session_id, uint8_t sess_id_size)
 {
     printf(unsupported_str);
     return NULL;
 }
 #endif
 
 #if !defined(CONFIG_SSL_CERT_VERIFICATION)
 EXP_FUNC int STDCALL ssl_verify_cert(const SSL *ssl)
 {
     printf(unsupported_str);
     return -1;
 }
 
 
 EXP_FUNC const char * STDCALL ssl_get_cert_dn(const SSL *ssl, int component)
 {
     printf(unsupported_str);
     return NULL;
 }
 
 EXP_FUNC const char * STDCALL ssl_get_cert_subject_alt_dnsname(const SSL *ssl, int index)
 {
     printf(unsupported_str);
     return NULL;
 }
 
 #endif  /* CONFIG_SSL_CERT_VERIFICATION */
 
 #endif /* CONFIG_BINDINGS */
 
Index: ssl/asn1.c
===================================================================
--- ssl/asn1.c	(revision 226)
+++ ssl/asn1.c	(revision 225)
@@ -1,566 +1,566 @@
 /*
  * Copyright (c) 2007, Cameron Rich
  * 
  * All rights reserved.
  * 
  * Redistribution and use in source and binary forms, with or without 
  * modification, are permitted provided that the following conditions are met:
  *
  * * Redistributions of source code must retain the above copyright notice, 
  *   this list of conditions and the following disclaimer.
  * * Redistributions in binary form must reproduce the above copyright notice, 
  *   this list of conditions and the following disclaimer in the documentation 
  *   and/or other materials provided with the distribution.
  * * Neither the name of the axTLS project nor the names of its contributors 
  *   may be used to endorse or promote products derived from this software 
  *   without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 /**
  * Some primitive asn methods for extraction ASN.1 data.
  */
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <time.h>
 #include "os_port.h"
 #include "crypto.h"
 #include "crypto_misc.h"
 
 #define SIG_OID_PREFIX_SIZE 8
 #define SIG_IIS6_OID_SIZE   5
 #define SIG_SUBJECT_ALT_NAME_SIZE 3
 
 /* Must be an RSA algorithm with either SHA1 or MD5 for verifying to work */
 static const uint8_t sig_oid_prefix[SIG_OID_PREFIX_SIZE] = 
 {
     0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01
 };
 
 static const uint8_t sig_sha1WithRSAEncrypt[SIG_IIS6_OID_SIZE] =
 {
     0x2b, 0x0e, 0x03, 0x02, 0x1d
 };
 
 static const uint8_t sig_subject_alt_name[SIG_SUBJECT_ALT_NAME_SIZE] =
 {
     0x55, 0x1d, 0x11
 };
 
 /* CN, O, OU */
 static const uint8_t g_dn_types[] = { 3, 10, 11 };
 
 int get_asn1_length(const uint8_t *buf, int *offset)
 {
     int len, i;
 
     if (!(buf[*offset] & 0x80)) /* short form */
     {
         len = buf[(*offset)++];
     }
     else  /* long form */
     {
         int length_bytes = buf[(*offset)++]&0x7f;
         len = 0;
         for (i = 0; i < length_bytes; i++)
         {
             len <<= 8;
             len += buf[(*offset)++];
         }
     }
 
     return len;
 }
 
 /**
  * Skip the ASN1.1 object type and its length. Get ready to read the object's
  * data.
  */
 int asn1_next_obj(const uint8_t *buf, int *offset, int obj_type)
 {
     if (buf[*offset] != obj_type)
         return X509_NOT_OK;
     (*offset)++;
     return get_asn1_length(buf, offset);
 }
 
 /**
  * Skip over an ASN.1 object type completely. Get ready to read the next
  * object.
  */
 int asn1_skip_obj(const uint8_t *buf, int *offset, int obj_type)
 {
     int len;
 
     if (buf[*offset] != obj_type)
         return X509_NOT_OK;
     (*offset)++;
     len = get_asn1_length(buf, offset);
     *offset += len;
     return 0;
 }
 
 /**
  * Read an integer value for ASN.1 data
  * Note: This function allocates memory which must be freed by the user.
  */
 int asn1_get_int(const uint8_t *buf, int *offset, uint8_t **object)
 {
     int len;
 
     if ((len = asn1_next_obj(buf, offset, ASN1_INTEGER)) < 0)
         goto end_int_array;
 
     if (len > 1 && buf[*offset] == 0x00)    /* ignore the negative byte */
     {
         len--;
         (*offset)++;
     }
 
     *object = (uint8_t *)malloc(len);
     memcpy(*object, &buf[*offset], len);
     *offset += len;
 
 end_int_array:
     return len;
 }
 
 /**
  * Get all the RSA private key specifics from an ASN.1 encoded file 
  */
 int asn1_get_private_key(const uint8_t *buf, int len, RSA_CTX **rsa_ctx)
 {
     int offset = 7;
     uint8_t *modulus = NULL, *priv_exp = NULL, *pub_exp = NULL;
     int mod_len, priv_len, pub_len;
 #ifdef CONFIG_BIGINT_CRT
     uint8_t *p = NULL, *q = NULL, *dP = NULL, *dQ = NULL, *qInv = NULL;
     int p_len, q_len, dP_len, dQ_len, qInv_len;
 #endif
 
     /* not in der format */
     if (buf[0] != ASN1_SEQUENCE) /* basic sanity check */
     {
 #ifdef CONFIG_SSL_FULL_MODE
         printf("Error: This is not a valid ASN.1 file\n");
 #endif
         return X509_INVALID_PRIV_KEY;
     }
 
-    /* Use the private key to mix up the RNG if possible. */
-    RNG_custom_init(buf, len);
+    /* initialise the RNG */
+    RNG_initialize(buf, len);
 
     mod_len = asn1_get_int(buf, &offset, &modulus);
     pub_len = asn1_get_int(buf, &offset, &pub_exp);
     priv_len = asn1_get_int(buf, &offset, &priv_exp);
 
     if (mod_len <= 0 || pub_len <= 0 || priv_len <= 0)
         return X509_INVALID_PRIV_KEY;
 
 #ifdef CONFIG_BIGINT_CRT
     p_len = asn1_get_int(buf, &offset, &p);
     q_len = asn1_get_int(buf, &offset, &q);
     dP_len = asn1_get_int(buf, &offset, &dP);
     dQ_len = asn1_get_int(buf, &offset, &dQ);
     qInv_len = asn1_get_int(buf, &offset, &qInv);
 
     if (p_len <= 0 || q_len <= 0 || dP_len <= 0 || dQ_len <= 0 || qInv_len <= 0)
         return X509_INVALID_PRIV_KEY;
 
     RSA_priv_key_new(rsa_ctx, 
             modulus, mod_len, pub_exp, pub_len, priv_exp, priv_len,
             p, p_len, q, p_len, dP, dP_len, dQ, dQ_len, qInv, qInv_len);
 
     free(p);
     free(q);
     free(dP);
     free(dQ);
     free(qInv);
 #else
     RSA_priv_key_new(rsa_ctx, 
             modulus, mod_len, pub_exp, pub_len, priv_exp, priv_len);
 #endif
 
     free(modulus);
     free(priv_exp);
     free(pub_exp);
     return X509_OK;
 }
 
 /**
  * Get the time of a certificate. Ignore hours/minutes/seconds.
  */
 static int asn1_get_utc_time(const uint8_t *buf, int *offset, time_t *t)
 {
     int ret = X509_NOT_OK, len, t_offset;
     struct tm tm;
 
     if (buf[(*offset)++] != ASN1_UTC_TIME)
         goto end_utc_time;
 
     len = get_asn1_length(buf, offset);
     t_offset = *offset;
 
     memset(&tm, 0, sizeof(struct tm));
     tm.tm_year = (buf[t_offset] - '0')*10 + (buf[t_offset+1] - '0');
 
     if (tm.tm_year <= 50)    /* 1951-2050 thing */
     {
         tm.tm_year += 100;
     }
 
     tm.tm_mon = (buf[t_offset+2] - '0')*10 + (buf[t_offset+3] - '0') - 1;
     tm.tm_mday = (buf[t_offset+4] - '0')*10 + (buf[t_offset+5] - '0');
     *t = mktime(&tm);
     *offset += len;
     ret = X509_OK;
 
 end_utc_time:
     return ret;
 }
 
 /**
  * Get the version type of a certificate (which we don't actually care about)
  */
 int asn1_version(const uint8_t *cert, int *offset, X509_CTX *x509_ctx)
 {
     int ret = X509_NOT_OK;
 
     (*offset) += 2;        /* get past explicit tag */
     if (asn1_skip_obj(cert, offset, ASN1_INTEGER))
         goto end_version;
 
     ret = X509_OK;
 end_version:
     return ret;
 }
 
 /**
  * Retrieve the notbefore and notafter certificate times.
  */
 int asn1_validity(const uint8_t *cert, int *offset, X509_CTX *x509_ctx)
 {
     return (asn1_next_obj(cert, offset, ASN1_SEQUENCE) < 0 ||
               asn1_get_utc_time(cert, offset, &x509_ctx->not_before) ||
               asn1_get_utc_time(cert, offset, &x509_ctx->not_after));
 }
 
 /**
  * Get the components of a distinguished name 
  */
 static int asn1_get_oid_x520(const uint8_t *buf, int *offset)
 {
     int dn_type = 0;
     int len;
 
     if ((len = asn1_next_obj(buf, offset, ASN1_OID)) < 0)
         goto end_oid;
 
     /* expect a sequence of 2.5.4.[x] where x is a one of distinguished name 
        components we are interested in. */
     if (len == 3 && buf[(*offset)++] == 0x55 && buf[(*offset)++] == 0x04)
         dn_type = buf[(*offset)++];
     else
     {
         *offset += len;     /* skip over it */
     }
 
 end_oid:
     return dn_type;
 }
 
 /**
  * Obtain an ASN.1 printable string type.
  */
 static int asn1_get_printable_str(const uint8_t *buf, int *offset, char **str)
 {
     int len = X509_NOT_OK;
     int asn1_type = buf[*offset];
 
     /* some certs have this awful crud in them for some reason */
     if (asn1_type != ASN1_PRINTABLE_STR &&  
             asn1_type != ASN1_PRINTABLE_STR2 &&  
             asn1_type != ASN1_TELETEX_STR &&  
             asn1_type != ASN1_IA5_STR &&  
             asn1_type != ASN1_UNICODE_STR)
         goto end_pnt_str;
 
     (*offset)++;
     len = get_asn1_length(buf, offset);
 
     if (asn1_type == ASN1_UNICODE_STR)
     {
         int i;
         *str = (char *)malloc(len/2+1);     /* allow for null */
 
         for (i = 0; i < len; i += 2)
             (*str)[i/2] = buf[*offset + i + 1];
 
         (*str)[len/2] = 0;                  /* null terminate */
     }
     else
     {
         *str = (char *)malloc(len+1);       /* allow for null */
         memcpy(*str, &buf[*offset], len);
         (*str)[len] = 0;                    /* null terminate */
     }
 
     *offset += len;
 
 end_pnt_str:
     return len;
 }
 
 /**
  * Get the subject name (or the issuer) of a certificate.
  */
 int asn1_name(const uint8_t *cert, int *offset, char *dn[])
 {
     int ret = X509_NOT_OK;
     int dn_type;
     char *tmp;
 
     if (asn1_next_obj(cert, offset, ASN1_SEQUENCE) < 0)
         goto end_name;
 
     while (asn1_next_obj(cert, offset, ASN1_SET) >= 0)
     {
         int i, found = 0;
 
         if (asn1_next_obj(cert, offset, ASN1_SEQUENCE) < 0 ||
                (dn_type = asn1_get_oid_x520(cert, offset)) < 0)
             goto end_name;
 
         tmp = NULL;
 
         if (asn1_get_printable_str(cert, offset, &tmp) < 0)
         {
             free(tmp);
             goto end_name;
         }
 
         /* find the distinguished named type */
         for (i = 0; i < X509_NUM_DN_TYPES; i++)
         {
             if (dn_type == g_dn_types[i])
             {
                 if (dn[i] == NULL)
                 {
                     dn[i] = tmp;
                     found = 1;
                     break;
                 }
             }
         }
 
         if (found == 0) /* not found so get rid of it */
         {
             free(tmp);
         }
     }
 
     ret = X509_OK;
 end_name:
     return ret;
 }
 
 /**
  * Read the modulus and public exponent of a certificate.
  */
 int asn1_public_key(const uint8_t *cert, int *offset, X509_CTX *x509_ctx)
 {
     int ret = X509_NOT_OK, mod_len, pub_len;
     uint8_t *modulus = NULL, *pub_exp = NULL;
 
     if (asn1_next_obj(cert, offset, ASN1_SEQUENCE) < 0 ||
             asn1_skip_obj(cert, offset, ASN1_SEQUENCE) ||
             asn1_next_obj(cert, offset, ASN1_BIT_STRING) < 0)
         goto end_pub_key;
 
     (*offset)++;        /* ignore the padding bit field */
 
     if (asn1_next_obj(cert, offset, ASN1_SEQUENCE) < 0)
         goto end_pub_key;
 
     mod_len = asn1_get_int(cert, offset, &modulus);
     pub_len = asn1_get_int(cert, offset, &pub_exp);
 
     RSA_pub_key_new(&x509_ctx->rsa_ctx, modulus, mod_len, pub_exp, pub_len);
 
     free(modulus);
     free(pub_exp);
     ret = X509_OK;
 
 end_pub_key:
     return ret;
 }
 
 #ifdef CONFIG_SSL_CERT_VERIFICATION
 /**
  * Read the signature of the certificate.
  */
 int asn1_signature(const uint8_t *cert, int *offset, X509_CTX *x509_ctx)
 {
     int ret = X509_NOT_OK;
 
     if (cert[(*offset)++] != ASN1_BIT_STRING)
         goto end_sig;
 
     x509_ctx->sig_len = get_asn1_length(cert, offset)-1;
     (*offset)++;            /* ignore bit string padding bits */
     x509_ctx->signature = (uint8_t *)malloc(x509_ctx->sig_len);
     memcpy(x509_ctx->signature, &cert[*offset], x509_ctx->sig_len);
     *offset += x509_ctx->sig_len;
     ret = X509_OK;
 
 end_sig:
     return ret;
 }
 
 /*
  * Compare 2 distinguished name components for equality 
  * @return 0 if a match
  */
 static int asn1_compare_dn_comp(const char *dn1, const char *dn2)
 {
     int ret;
 
     if (dn1 == NULL && dn2 == NULL)
         ret = 0;
     else
         ret = (dn1 && dn2) ? strcmp(dn1, dn2) : 1;
 
     return ret;
 }
 
 /**
  * Clean up all of the CA certificates.
  */
 void remove_ca_certs(CA_CERT_CTX *ca_cert_ctx)
 {
     int i = 0;
 
     if (ca_cert_ctx == NULL)
         return;
 
     while (i < CONFIG_X509_MAX_CA_CERTS && ca_cert_ctx->cert[i])
     {
         x509_free(ca_cert_ctx->cert[i]);
         ca_cert_ctx->cert[i++] = NULL;
     }
 
     free(ca_cert_ctx);
 }
 
 /*
  * Compare 2 distinguished names for equality 
  * @return 0 if a match
  */
 int asn1_compare_dn(char * const dn1[], char * const dn2[])
 {
     int i;
 
     for (i = 0; i < X509_NUM_DN_TYPES; i++)
     {
         if (asn1_compare_dn_comp(dn1[i], dn2[i]))
             return 1;
     }
 
     return 0;       /* all good */
 }
 
 int asn1_find_oid(const uint8_t* cert, int* offset, 
                     const uint8_t* oid, int oid_length)
 {
     int seqlen;
     if ((seqlen = asn1_next_obj(cert, offset, ASN1_SEQUENCE))> 0)
     {
         int end = *offset + seqlen;
 
         while (*offset < end)
         {
             int type = cert[(*offset)++];
             int length = get_asn1_length(cert, offset);
             int noffset = *offset + length;
 
             if (type == ASN1_SEQUENCE)
             {
                 type = cert[(*offset)++];
                 length = get_asn1_length(cert, offset);
 
                 if (type == ASN1_OID && length == oid_length && 
                               memcmp(cert + *offset, oid, oid_length) == 0)
                 {
                     *offset += oid_length;
                     return 1;
                 }
             }
 
             *offset = noffset;
         }
     }
 
     return 0;
 }
 
 int asn1_find_subjectaltname(const uint8_t* cert, int offset)
 {
     if (asn1_find_oid(cert, &offset, sig_subject_alt_name, 
                                 SIG_SUBJECT_ALT_NAME_SIZE))
     {
         return offset;
     }
 
     return 0;
 }
 
 #endif /* CONFIG_SSL_CERT_VERIFICATION */
 
 /**
  * Read the signature type of the certificate. We only support RSA-MD5 and
  * RSA-SHA1 signature types.
  */
 int asn1_signature_type(const uint8_t *cert, 
                                 int *offset, X509_CTX *x509_ctx)
 {
     int ret = X509_NOT_OK, len;
 
     if (cert[(*offset)++] != ASN1_OID)
         goto end_check_sig;
 
     len = get_asn1_length(cert, offset);
 
     if (len == 5 && memcmp(sig_sha1WithRSAEncrypt, &cert[*offset], 
                                     SIG_IIS6_OID_SIZE) == 0)
     {
         x509_ctx->sig_type = SIG_TYPE_SHA1;
     }
     else
     {
         if (memcmp(sig_oid_prefix, &cert[*offset], SIG_OID_PREFIX_SIZE))
             goto end_check_sig;     /* unrecognised cert type */
 
         x509_ctx->sig_type = cert[*offset + SIG_OID_PREFIX_SIZE];
     }
 
     *offset += len;
     asn1_skip_obj(cert, offset, ASN1_NULL); /* if it's there */
     ret = X509_OK;
 
 end_check_sig:
     return ret;
 }
 
Index: ssl/tls1.h
===================================================================
--- ssl/tls1.h	(revision 226)
+++ ssl/tls1.h	(revision 225)
@@ -1,296 +1,295 @@
 /*
  * Copyright (c) 2007, Cameron Rich
  * 
  * All rights reserved.
  * 
  * Redistribution and use in source and binary forms, with or without 
  * modification, are permitted provided that the following conditions are met:
  *
  * * Redistributions of source code must retain the above copyright notice, 
  *   this list of conditions and the following disclaimer.
  * * Redistributions in binary form must reproduce the above copyright notice, 
  *   this list of conditions and the following disclaimer in the documentation 
  *   and/or other materials provided with the distribution.
  * * Neither the name of the axTLS project nor the names of its contributors 
  *   may be used to endorse or promote products derived from this software 
  *   without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 /**
  * @file tls1.h
  *
  * @brief The definitions for the TLS library.
  */
 #ifndef HEADER_SSL_LIB_H
 #define HEADER_SSL_LIB_H
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
 #include "version.h"
 #include "crypto.h"
-#include "os_int.h"
 #include "crypto_misc.h"
 
 #define SSL_PROTOCOL_MIN_VERSION    0x31   /* TLS v1.0 */
 #define SSL_PROTOCOL_MINOR_VERSION  0x02   /* TLS v1.1 */
 #define SSL_PROTOCOL_VERSION_MAX    0x32   /* TLS v1.1 */
 #define SSL_PROTOCOL_VERSION1_1     0x32   /* TLS v1.1 */
 #define SSL_RANDOM_SIZE             32
 #define SSL_SECRET_SIZE             48
 #define SSL_FINISHED_HASH_SIZE      12
 #define SSL_RECORD_SIZE             5
 #define SSL_SERVER_READ             0
 #define SSL_SERVER_WRITE            1
 #define SSL_CLIENT_READ             2
 #define SSL_CLIENT_WRITE            3
 #define SSL_HS_HDR_SIZE             4
 
 /* the flags we use while establishing a connection */
 #define SSL_NEED_RECORD             0x0001
 #define SSL_TX_ENCRYPTED            0x0002 
 #define SSL_RX_ENCRYPTED            0x0004
 #define SSL_SESSION_RESUME          0x0008
 #define SSL_IS_CLIENT               0x0010
 #define SSL_HAS_CERT_REQ            0x0020
 #define SSL_SENT_CLOSE_NOTIFY       0x0040
 
 /* some macros to muck around with flag bits */
 #define SET_SSL_FLAG(A)             (ssl->flag |= A)
 #define CLR_SSL_FLAG(A)             (ssl->flag &= ~A)
 #define IS_SET_SSL_FLAG(A)          (ssl->flag & A)
 
 #define MAX_KEY_BYTE_SIZE           512     /* for a 4096 bit key */
 #define RT_MAX_PLAIN_LENGTH         16384
 #define RT_EXTRA                    1024
 #define BM_RECORD_OFFSET            5
 
 #ifdef CONFIG_SSL_SKELETON_MODE
 #define NUM_PROTOCOLS               1
 #else
 #define NUM_PROTOCOLS               4
 #endif
 
 #define PARANOIA_CHECK(A, B)        if (A < B) { \
     ret = SSL_ERROR_INVALID_HANDSHAKE; goto error; }
 
 /* protocol types */
 enum
 {
     PT_CHANGE_CIPHER_SPEC = 20,
     PT_ALERT_PROTOCOL,
     PT_HANDSHAKE_PROTOCOL,
     PT_APP_PROTOCOL_DATA
 };
 
 /* handshaking types */
 enum
 {
     HS_HELLO_REQUEST,
     HS_CLIENT_HELLO,
     HS_SERVER_HELLO,
     HS_CERTIFICATE = 11,
     HS_SERVER_KEY_XCHG,
     HS_CERT_REQ,
     HS_SERVER_HELLO_DONE,
     HS_CERT_VERIFY,
     HS_CLIENT_KEY_XCHG,
     HS_FINISHED = 20
 };
 
 typedef struct 
 {
     uint8_t cipher;
     uint8_t key_size;
     uint8_t iv_size;
     uint8_t key_block_size;
     uint8_t padding_size;
     uint8_t digest_size;
     hmac_func hmac;
     crypt_func encrypt;
     crypt_func decrypt;
 } cipher_info_t;
 
 struct _SSLObjLoader 
 {
     uint8_t *buf;
     int len;
 };
 
 typedef struct _SSLObjLoader SSLObjLoader;
 
 typedef struct 
 {
     time_t conn_time;
     uint8_t session_id[SSL_SESSION_ID_SIZE];
     uint8_t master_secret[SSL_SECRET_SIZE];
 } SSL_SESSION;
 
 typedef struct
 {
     uint8_t *buf;
     int size;
 } SSL_CERT;
 
 typedef struct
 {
     MD5_CTX md5_ctx;
     SHA1_CTX sha1_ctx;
     uint8_t final_finish_mac[SSL_FINISHED_HASH_SIZE];
     uint8_t *key_block;
     uint8_t master_secret[SSL_SECRET_SIZE];
     uint8_t client_random[SSL_RANDOM_SIZE]; /* client's random sequence */
     uint8_t server_random[SSL_RANDOM_SIZE]; /* server's random sequence */
     uint16_t bm_proc_index;
 } DISPOSABLE_CTX;
 
 struct _SSL
 {
     uint32_t flag;
     uint16_t need_bytes;
     uint16_t got_bytes;
     uint8_t record_type;
     uint8_t cipher;
     uint8_t sess_id_size;
     uint8_t version;
     uint8_t client_version;
     int16_t next_state;
     int16_t hs_status;
     DISPOSABLE_CTX *dc;         /* temporary data which we'll get rid of soon */
     int client_fd;
     const cipher_info_t *cipher_info;
     void *encrypt_ctx;
     void *decrypt_ctx;
     uint8_t bm_all_data[RT_MAX_PLAIN_LENGTH+RT_EXTRA];
     uint8_t *bm_data;
     uint16_t bm_index;
     uint16_t bm_read_index;
     struct _SSL *next;                  /* doubly linked list */
     struct _SSL *prev;
     struct _SSL_CTX *ssl_ctx;           /* back reference to a clnt/svr ctx */
 #ifndef CONFIG_SSL_SKELETON_MODE
     uint16_t session_index;
     SSL_SESSION *session;
 #endif
 #ifdef CONFIG_SSL_CERT_VERIFICATION
     X509_CTX *x509_ctx;
 #endif
 
     uint8_t session_id[SSL_SESSION_ID_SIZE]; 
     uint8_t client_mac[SHA1_SIZE];  /* for HMAC verification */
     uint8_t server_mac[SHA1_SIZE];  /* for HMAC verification */
     uint8_t read_sequence[8];       /* 64 bit sequence number */
     uint8_t write_sequence[8];      /* 64 bit sequence number */
     uint8_t hmac_header[SSL_RECORD_SIZE];    /* rx hmac */
 };
 
 typedef struct _SSL SSL;
 
 struct _SSL_CTX
 {
     uint32_t options;
     uint8_t chain_length;
     RSA_CTX *rsa_ctx;
 #ifdef CONFIG_SSL_CERT_VERIFICATION
     CA_CERT_CTX *ca_cert_ctx;
 #endif
     SSL *head;
     SSL *tail;
     SSL_CERT certs[CONFIG_SSL_MAX_CERTS];
 #ifndef CONFIG_SSL_SKELETON_MODE
     uint16_t num_sessions;
     SSL_SESSION **ssl_sessions;
 #endif
 #ifdef CONFIG_SSL_CTX_MUTEXING
     SSL_CTX_MUTEX_TYPE mutex;
 #endif
 #ifdef CONFIG_OPENSSL_COMPATIBLE
     void *bonus_attr;
 #endif
 };
 
 typedef struct _SSL_CTX SSL_CTX;
 
 /* backwards compatibility */
 typedef struct _SSL_CTX SSLCTX;
 
 extern const uint8_t ssl_prot_prefs[NUM_PROTOCOLS];
 
 SSL *ssl_new(SSL_CTX *ssl_ctx, int client_fd);
 void disposable_new(SSL *ssl);
 void disposable_free(SSL *ssl);
 int send_packet(SSL *ssl, uint8_t protocol, 
         const uint8_t *in, int length);
 int do_svr_handshake(SSL *ssl, int handshake_type, uint8_t *buf, int hs_len);
 int do_clnt_handshake(SSL *ssl, int handshake_type, uint8_t *buf, int hs_len);
 int process_finished(SSL *ssl, uint8_t *buf, int hs_len);
 int process_sslv23_client_hello(SSL *ssl);
 int send_alert(SSL *ssl, int error_code);
 int send_finished(SSL *ssl);
 int send_certificate(SSL *ssl);
 int basic_read(SSL *ssl, uint8_t **in_data);
 int send_change_cipher_spec(SSL *ssl);
 void finished_digest(SSL *ssl, const char *label, uint8_t *digest);
 void generate_master_secret(SSL *ssl, const uint8_t *premaster_secret);
 void add_packet(SSL *ssl, const uint8_t *pkt, int len);
 int add_cert(SSL_CTX *ssl_ctx, const uint8_t *buf, int len);
 int add_private_key(SSL_CTX *ssl_ctx, SSLObjLoader *ssl_obj);
 void ssl_obj_free(SSLObjLoader *ssl_obj);
 int pkcs8_decode(SSL_CTX *ssl_ctx, SSLObjLoader *ssl_obj, const char *password);
 int pkcs12_decode(SSL_CTX *ssl_ctx, SSLObjLoader *ssl_obj, const char *password);
 int load_key_certs(SSL_CTX *ssl_ctx);
 #ifdef CONFIG_SSL_CERT_VERIFICATION
 int add_cert_auth(SSL_CTX *ssl_ctx, const uint8_t *buf, int len);
 void remove_ca_certs(CA_CERT_CTX *ca_cert_ctx);
 #endif
 #ifdef CONFIG_SSL_ENABLE_CLIENT
 int do_client_connect(SSL *ssl);
 #endif
 
 #ifdef CONFIG_SSL_FULL_MODE
 void DISPLAY_STATE(SSL *ssl, int is_send, uint8_t state, int not_ok);
 void DISPLAY_BYTES(SSL *ssl, const char *format, 
         const uint8_t *data, int size, ...);
 void DISPLAY_CERT(SSL *ssl, const X509_CTX *x509_ctx);
 void DISPLAY_RSA(SSL *ssl,  const RSA_CTX *rsa_ctx);
 void DISPLAY_ALERT(SSL *ssl, int alert);
 #else
 #define DISPLAY_STATE(A,B,C,D)
 #define DISPLAY_CERT(A,B)
 #define DISPLAY_RSA(A,B)
 #define DISPLAY_ALERT(A, B)
 #ifdef WIN32
 void DISPLAY_BYTES(SSL *ssl, const char *format,/* win32 has no variadic macros */
         const uint8_t *data, int size, ...);
 #else
 #define DISPLAY_BYTES(A,B,C,D,...)
 #endif
 #endif
 
 #ifdef CONFIG_SSL_CERT_VERIFICATION
 int process_certificate(SSL *ssl, X509_CTX **x509_ctx);
 #endif
 
 SSL_SESSION *ssl_session_update(int max_sessions, 
         SSL_SESSION *ssl_sessions[], SSL *ssl,
         const uint8_t *session_id);
 void kill_ssl_session(SSL_SESSION **ssl_sessions, SSL *ssl);
 
 #ifdef __cplusplus
 }
 #endif
 
 #endif 
Index: ssl/os_port.h
===================================================================
--- ssl/os_port.h	(revision 226)
+++ ssl/os_port.h	(revision 225)
@@ -1,191 +1,204 @@
 /*
  * Copyright (c) 2007, Cameron Rich
  * 
  * All rights reserved.
  * 
  * Redistribution and use in source and binary forms, with or without 
  * modification, are permitted provided that the following conditions are met:
  *
  * * Redistributions of source code must retain the above copyright notice, 
  *   this list of conditions and the following disclaimer.
  * * Redistributions in binary form must reproduce the above copyright notice, 
  *   this list of conditions and the following disclaimer in the documentation 
  *   and/or other materials provided with the distribution.
  * * Neither the name of the axTLS project nor the names of its contributors 
  *   may be used to endorse or promote products derived from this software 
  *   without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 /**
  * @file os_port.h
  *
  * Some stuff to minimise the differences between windows and linux/unix
  */
 
 #ifndef HEADER_OS_PORT_H
 #define HEADER_OS_PORT_H
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-#include "os_int.h"
 #include <stdio.h>
 
 #if defined(WIN32)
 #define STDCALL                 __stdcall
 #define EXP_FUNC                __declspec(dllexport)
 #else
 #define STDCALL
 #define EXP_FUNC
 #endif
 
 #if defined(_WIN32_WCE)
 #undef WIN32
 #define WIN32
 #endif
 
 #ifdef WIN32
 
 /* Windows CE stuff */
 #if defined(_WIN32_WCE)
 #include <basetsd.h>
 #define abort()                 exit(1)
 #else
 #include <io.h>
 #include <process.h>
 #include <sys/timeb.h>
 #include <fcntl.h>
 #endif      /* _WIN32_WCE */
 
 #include <winsock.h>
 #include <direct.h>
 #undef getpid
 #undef open
 #undef close
 #undef sleep
 #undef gettimeofday
 #undef dup2
 #undef unlink
 
 #define SOCKET_READ(A,B,C)      recv(A,B,C,0)
 #define SOCKET_WRITE(A,B,C)     send(A,B,C,0)
 #define SOCKET_CLOSE(A)         closesocket(A)
 #define srandom(A)              srand(A)
 #define random()                rand()
 #define getpid()                _getpid()
 #define snprintf                _snprintf
 #define open(A,B)               _open(A,B)
 #define dup2(A,B)               _dup2(A,B)
 #define unlink(A)               _unlink(A)
 #define close(A)                _close(A)
 #define read(A,B,C)             _read(A,B,C)
 #define write(A,B,C)            _write(A,B,C)
 #define sleep(A)                Sleep(A*1000)
 #define usleep(A)               Sleep(A/1000)
 #define strdup(A)               _strdup(A)
 #define chroot(A)               _chdir(A)
 #define chdir(A)                _chdir(A)
 #define alloca(A)               _alloca(A)
 #ifndef lseek
 #define lseek(A,B,C)            _lseek(A,B,C)
 #endif
 
 /* This fix gets around a problem where a win32 application on a cygwin xterm
    doesn't display regular output (until a certain buffer limit) - but it works
    fine under a normal DOS window. This is a hack to get around the issue - 
    see http://www.khngai.com/emacs/tty.php  */
 #define TTY_FLUSH()             if (!_isatty(_fileno(stdout))) fflush(stdout);
 
 /*
  * automatically build some library dependencies.
  */
 #pragma comment(lib, "WS2_32.lib")
 #pragma comment(lib, "AdvAPI32.lib")
 
+typedef UINT8 uint8_t;
+typedef INT8 int8_t;
+typedef UINT16 uint16_t;
+typedef INT16 int16_t;
+typedef UINT32 uint32_t;
+typedef INT32 int32_t;
+typedef UINT64 uint64_t;
+typedef INT64 int64_t;
 typedef int socklen_t;
 
 EXP_FUNC void STDCALL gettimeofday(struct timeval* t,void* timezone);
 EXP_FUNC int STDCALL strcasecmp(const char *s1, const char *s2);
 EXP_FUNC int STDCALL getdomainname(char *buf, int buf_size);
 
 #else   /* Not Win32 */
 
+#ifdef CONFIG_PLATFORM_SOLARIS
+#include <inttypes.h>
+#else
+#include <stdint.h>
+#endif /* Not Solaris */
+
 #include <unistd.h>
 #include <pwd.h>
 #include <netdb.h>
 #include <dirent.h>
 #include <fcntl.h>
 #include <errno.h>
 #include <sys/stat.h>
 #include <sys/time.h>
 #include <sys/socket.h>
 #include <sys/wait.h>
 #include <netinet/in.h>
 #include <arpa/inet.h>
 
 #define SOCKET_READ(A,B,C)      read(A,B,C)
 #define SOCKET_WRITE(A,B,C)     write(A,B,C)
 #define SOCKET_CLOSE(A)         if (A >= 0) close(A)
 #define TTY_FLUSH()
 
 #endif  /* Not Win32 */
 
 /* some functions to mutate the way these work */
 #define malloc(A)       ax_malloc(A)
 #ifndef realloc
 #define realloc(A,B)    ax_realloc(A,B)
 #endif
 #define calloc(A,B)     ax_calloc(A,B)
 
 EXP_FUNC void * STDCALL ax_malloc(size_t s);
 EXP_FUNC void * STDCALL ax_realloc(void *y, size_t s);
 EXP_FUNC void * STDCALL ax_calloc(size_t n, size_t s);
 EXP_FUNC int STDCALL ax_open(const char *pathname, int flags); 
 
 #ifdef CONFIG_PLATFORM_LINUX
 void exit_now(const char *format, ...) __attribute((noreturn));
 #else
 void exit_now(const char *format, ...);
 #endif
 
 /* Mutexing definitions */
 #if defined(CONFIG_SSL_CTX_MUTEXING)
 #if defined(WIN32)
 #define SSL_CTX_MUTEX_TYPE          HANDLE
 #define SSL_CTX_MUTEX_INIT(A)       A=CreateMutex(0, FALSE, 0)
 #define SSL_CTX_MUTEX_DESTROY(A)    CloseHandle(A)
 #define SSL_CTX_LOCK(A)             WaitForSingleObject(A, INFINITE)
 #define SSL_CTX_UNLOCK(A)           ReleaseMutex(A)
 #else 
 #include <pthread.h>
 #define SSL_CTX_MUTEX_TYPE          pthread_mutex_t
 #define SSL_CTX_MUTEX_INIT(A)       pthread_mutex_init(&A, NULL)
 #define SSL_CTX_MUTEX_DESTROY(A)    pthread_mutex_destroy(&A)
 #define SSL_CTX_LOCK(A)             pthread_mutex_lock(&A)
 #define SSL_CTX_UNLOCK(A)           pthread_mutex_unlock(&A)
 #endif
 #else   /* no mutexing */
 #define SSL_CTX_MUTEX_INIT(A)
 #define SSL_CTX_MUTEX_DESTROY(A)
 #define SSL_CTX_LOCK(A)
 #define SSL_CTX_UNLOCK(A)
 #endif
 
 #ifdef __cplusplus
 }
 #endif
 
 #endif 
Index: httpd/axhttpd.c
===================================================================
--- httpd/axhttpd.c	(revision 226)
+++ httpd/axhttpd.c	(revision 225)
@@ -1,671 +1,668 @@
 /*
  * Copyright (c) Cameron Rich
  * 
  * All rights reserved.
  * 
  * Redistribution and use in source and binary forms, with or without 
  * modification, are permitted provided that the following conditions are met:
  *
  * * Redistributions of source code must retain the above copyright notice, 
  *   this list of conditions and the following disclaimer.
  * * Redistributions in binary form must reproduce the above copyright notice, 
  *   this list of conditions and the following disclaimer in the documentation 
  *   and/or other materials provided with the distribution.
  * * Neither the name of the axTLS project nor the names of its contributors 
  *   may be used to endorse or promote products derived from this software 
  *   without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #include <stdio.h>
 #include <string.h>
 #include <sys/types.h>
 #include <signal.h>
 #include <stdlib.h>
 #include <sys/stat.h>
 
 #if !defined(WIN32)
 #include <pwd.h>
 #endif
 #include "axhttp.h"
 
 struct serverstruct *servers;
 struct connstruct *usedconns;
 struct connstruct *freeconns;
 const char * const server_version = "axhttpd/"AXTLS_VERSION;
 static const char *webroot = CONFIG_HTTP_WEBROOT;
 
 static void addtoservers(int sd);
 static int openlistener(char *address, int port);
 static void handlenewconnection(int listenfd, int is_ssl);
 static void addconnection(int sd, char *ip, int is_ssl);
 static void ax_chdir(void);
 
 #if defined(CONFIG_HTTP_HAS_CGI)
 struct cgiextstruct *cgiexts;
 static void addcgiext(const char *tp);
 
 #if !defined(WIN32)
 static void reaper(int sigtype) 
 {
     while (wait3(NULL, WNOHANG, NULL) > 0)
         continue;
 }
 #endif
 #endif
 
 #ifdef CONFIG_HTTP_VERBOSE  /* should really be in debug mode or something */
 /* clean up memory for valgrind */
 static void sigint_cleanup(int sig)
 {
     struct serverstruct *sp;
     struct connstruct *tp;
 
     while (servers != NULL) 
     {
         if (servers->is_ssl)
             ssl_ctx_free(servers->ssl_ctx);
 
         sp = servers->next;
         free(servers);
         servers = sp;
     }
 
     while (freeconns != NULL)
     {
         tp = freeconns->next;
         free(freeconns);
         freeconns = tp;
     }
 
     while (usedconns != NULL)
     {
         tp = usedconns->next;
         free(usedconns);
         usedconns = tp;
     }
 
 #if defined(CONFIG_HTTP_HAS_CGI)
     while (cgiexts)
     {
         struct cgiextstruct *cp = cgiexts->next;
         if (cp == NULL) /* last entry */
             free(cgiexts->ext);
         free(cgiexts);
         cgiexts = cp;
     }
 #endif
 
     exit(0);
 }
 
 static void die(int sigtype) 
 {
     exit(0);
 }
 #endif
 
 int main(int argc, char *argv[]) 
 {
     fd_set rfds, wfds;
     struct connstruct *tp, *to;
     struct serverstruct *sp;
     int rnum, wnum, active;
     int i = 1;
     time_t currtime;
     char *httpAddress = NULL;
     int httpPort = CONFIG_HTTP_PORT;
     char *httpsAddress = NULL;
     int httpsPort = CONFIG_HTTP_HTTPS_PORT;
     char *portStr;
 
 #ifdef WIN32
     WORD wVersionRequested = MAKEWORD(2, 2);
     WSADATA wsaData;
     WSAStartup(wVersionRequested,&wsaData);
 #else
     signal(SIGPIPE, SIG_IGN);
 #if defined(CONFIG_HTTP_HAS_CGI)
     signal(SIGCHLD, reaper);
 #endif
 #ifdef CONFIG_HTTP_VERBOSE
     signal(SIGQUIT, die);
 #endif
 #endif
 
 #ifdef CONFIG_HTTP_VERBOSE
     signal(SIGTERM, die);
     signal(SIGINT, sigint_cleanup);
 #endif
     tdate_init();
 
     /* get some command-line parameters */
     while (argv[i] != NULL)
     {
         if (strcmp(argv[i], "-p") == 0 && argv[i+1] != NULL)
         {
             if ((portStr = strchr(argv[i+1], ':')) != NULL)
             {
                 httpAddress = argv[i+1];
                 *portStr = 0;
                 httpPort = atoi(portStr + 1);
             }
             else
                 httpPort = atoi(argv[i+1]);
 
             i += 2;
             continue;
         }
 
         if (strcmp(argv[i], "-s") == 0 && argv[i+1] != NULL)
         {
             if ((portStr = strchr(argv[i+1], ':')) != NULL)
             {
                 httpsAddress = argv[i+1];
                 *portStr = 0;
                 httpsPort = atoi(portStr + 1);
             }
             else
                 httpsPort = atoi(argv[i+1]);
 
             i += 2;
             continue;
         }
 
         if (strcmp(argv[i], "-w") == 0 && argv[i+1] != NULL)
         {
             webroot = argv[i+1];
             i += 2;
             continue;
         }
 
         printf("%s:\n"
                "    [-p [address:]httpport]\n"
                "    [-s [address:]httpsport]\n"
                "    [-w webroot]\n", argv[0]);
         exit(1);
     }
 
     for (i = 0; i < INITIAL_CONNECTION_SLOTS; i++) 
     {
         tp = freeconns;
         freeconns = (struct connstruct *)calloc(1, sizeof(struct connstruct));
         freeconns->next = tp;
     }
 
     if ((active = openlistener(httpAddress, httpPort)) == -1) 
     {
 #ifdef CONFIG_HTTP_VERBOSE
         fprintf(stderr, "ERR: Couldn't bind to port %d\n", httpPort);
 #endif
         exit(1);
     }
 
     addtoservers(active);
 
     if ((active = openlistener(httpsAddress, httpsPort)) == -1) 
     {
 #ifdef CONFIG_HTTP_VERBOSE
         fprintf(stderr, "ERR: Couldn't bind to port %d\n", httpsPort);
 #endif
         exit(1);
     }
 
     addtoservers(active);
     servers->ssl_ctx = ssl_ctx_new(CONFIG_HTTP_DEFAULT_SSL_OPTIONS, 
                                 CONFIG_HTTP_SESSION_CACHE_SIZE);
     servers->is_ssl = 1;
 
 #if defined(CONFIG_HTTP_HAS_CGI)
     addcgiext(CONFIG_HTTP_CGI_EXTENSIONS);
 #endif
 
 #if defined(CONFIG_HTTP_VERBOSE)
 #if defined(CONFIG_HTTP_HAS_CGI)
     printf("addcgiext %s\n", CONFIG_HTTP_CGI_EXTENSIONS); 
 #endif
     printf("%s: listening on ports %d (http) and %d (https)\n", 
             server_version, httpPort, httpsPort);
     TTY_FLUSH();
 #endif
 
     ax_chdir();
 
 #ifdef CONFIG_HTTP_ENABLE_DIFFERENT_USER
     {
         struct passwd *pd = getpwnam(CONFIG_HTTP_USER);
 
         if (pd != NULL)
         {
             int res = setuid(pd->pw_uid);
             res |= setgid(pd->pw_gid);
 
 #if defined(CONFIG_HTTP_VERBOSE)
             if (res == 0)
             {
                 printf("change to '%s' successful\n", CONFIG_HTTP_USER); 
                 TTY_FLUSH();
             }
 #endif
         }
 
     }
 #endif
 
 
 #ifndef WIN32 
 #ifdef CONFIG_HTTP_IS_DAEMON
     if (fork() > 0)  /* parent will die */
         exit(0);
 
     setsid();
 #endif
 #endif
 
     /* main loop */
     while (1)
     {
         struct timeval tv = { 10, 0 };
         FD_ZERO(&rfds);
         FD_ZERO(&wfds);
         rnum = wnum = -1;
         sp = servers;
 
         while (sp != NULL)  /* read each server port */
         {
             FD_SET(sp->sd, &rfds);
 
             if (sp->sd > rnum) 
                 rnum = sp->sd;
             sp = sp->next;
         }
 
         /* Add the established sockets */
         tp = usedconns;
         currtime = time(NULL);
 
         while (tp != NULL) 
         {
             if (currtime > tp->timeout)     /* timed out? Kill it. */
             {
                 to = tp;
                 tp = tp->next;
                 removeconnection(to);
                 continue;
             }
 
             if (tp->state == STATE_WANT_TO_READ_HEAD) 
             {
                 FD_SET(tp->networkdesc, &rfds);
                 if (tp->networkdesc > rnum) 
                     rnum = tp->networkdesc;
             }
 
             if (tp->state == STATE_WANT_TO_SEND_HEAD) 
             {
                 FD_SET(tp->networkdesc, &wfds);
                 if (tp->networkdesc > wnum) 
                     wnum = tp->networkdesc;
             }
 
             if (tp->state == STATE_WANT_TO_READ_FILE) 
             {
                 FD_SET(tp->filedesc, &rfds);
                 if (tp->filedesc > rnum) 
                     rnum = tp->filedesc;
             }
 
             if (tp->state == STATE_WANT_TO_SEND_FILE) 
             {
                 FD_SET(tp->networkdesc, &wfds);
                 if (tp->networkdesc > wnum) 
                     wnum = tp->networkdesc;
             }
 
 #if defined(CONFIG_HTTP_DIRECTORIES)
             if (tp->state == STATE_DOING_DIR) 
             {
                 FD_SET(tp->networkdesc, &wfds);
                 if (tp->networkdesc > wnum) 
                     wnum = tp->networkdesc;
             }
 #endif
             tp = tp->next;
         }
 
         active = select(wnum > rnum ? wnum+1 : rnum+1,
                 rnum != -1 ? &rfds : NULL, 
                 wnum != -1 ? &wfds : NULL,
                 NULL, usedconns ? &tv : NULL);
 
         /* timeout? */
         if (active == 0)
             continue;
 
         /* New connection? */
         sp = servers;
         while (active > 0 && sp != NULL) 
         {
             if (FD_ISSET(sp->sd, &rfds)) 
             {
                 handlenewconnection(sp->sd, sp->is_ssl);
                 active--;
             }
 
             sp = sp->next;
         }
 
         /* Handle the established sockets */
         tp = usedconns;
 
         while (active > 0 && tp != NULL) 
         {
             to = tp;
             tp = tp->next;
 
             if (to->state == STATE_WANT_TO_READ_HEAD &&
                         FD_ISSET(to->networkdesc, &rfds)) 
             {
                 active--;
 #if defined(CONFIG_HTTP_HAS_CGI)
                 if (to->post_state)
                     read_post_data(to);
                 else
 #endif
                     procreadhead(to);
             } 
 
             if (to->state == STATE_WANT_TO_SEND_HEAD &&
                         FD_ISSET(to->networkdesc, &wfds)) 
             {
                 active--;
                 procsendhead(to);
             } 
 
             if (to->state == STATE_WANT_TO_READ_FILE && 
                         FD_ISSET(to->filedesc, &rfds)) 
             {
                 active--;
                 procreadfile(to);
             } 
 
             if (to->state == STATE_WANT_TO_SEND_FILE && 
                         FD_ISSET(to->networkdesc, &wfds)) 
             {
                 active--;
                 procsendfile(to);
             }
 
 #if defined(CONFIG_HTTP_DIRECTORIES)
             if (to->state == STATE_DOING_DIR &&
                         FD_ISSET(to->networkdesc, &wfds)) 
             {
                 active--;
                 procdodir(to);
             }
 #endif
         }
     }
 
     return 0;
 }
 
 #if defined(CONFIG_HTTP_HAS_CGI)
 static void addcgiext(const char *cgi_exts)
 {
     char *cp = strdup(cgi_exts);
 
     /* extenstions are comma separated */
     do 
     {
         struct cgiextstruct *ex = (struct cgiextstruct *)
                             malloc(sizeof(struct cgiextstruct));
         ex->ext = cp;
         ex->next = cgiexts;
         cgiexts = ex;
         if ((cp = strchr(cp, ',')) != NULL)
             *cp++ = 0;
     } while (cp != NULL);
 }
 #endif
 
 static void addtoservers(int sd) 
 {
     struct serverstruct *tp = (struct serverstruct *)
                             calloc(1, sizeof(struct serverstruct));
     tp->next = servers;
     tp->sd = sd;
     servers = tp;
 }
 
 #ifdef HAVE_IPV6
 static void handlenewconnection(int listenfd, int is_ssl) 
 {
     struct sockaddr_in6 their_addr;
-    socklen_t tp = sizeof(their_addr);
+    int tp = sizeof(their_addr);
     char ipbuf[100];
     int connfd = accept(listenfd, (struct sockaddr *)&their_addr, &tp);
 
     if (tp == sizeof(struct sockaddr_in6)) 
         inet_ntop(AF_INET6, &their_addr.sin6_addr, ipbuf, sizeof(ipbuf));
     else if (tp == sizeof(struct sockaddr_in)) 
         inet_ntop(AF_INET, &(((struct sockaddr_in *)&their_addr)->sin_addr),
                 ipbuf, sizeof(ipbuf));
     else 
         *ipbuf = '\0';
 
     if (connfd != -1) /* check for error condition */
         addconnection(connfd, ipbuf, is_ssl);
 }
 
 #else
 static void handlenewconnection(int listenfd, int is_ssl) 
 {
     struct sockaddr_in their_addr;
     socklen_t tp = sizeof(struct sockaddr_in);
     int connfd = accept(listenfd, (struct sockaddr *)&their_addr, &tp);
     addconnection(connfd, inet_ntoa(their_addr.sin_addr), is_ssl);
 }
 #endif
 
 static int openlistener(char *address, int port) 
 {
     int sd;
 #ifdef WIN32
     char tp = 1;
 #else
     int tp = 1;
 #endif
 #ifndef HAVE_IPV6
     struct sockaddr_in my_addr;
 
     if ((sd = socket(AF_INET, SOCK_STREAM, 0)) == -1) 
         return -1;
 
     memset(&my_addr, 0, sizeof(my_addr));
     my_addr.sin_family = AF_INET;
     my_addr.sin_port = htons((short)port);
     my_addr.sin_addr.s_addr = address == NULL ? 
                         INADDR_ANY : inet_addr(address);
 #else
     struct sockaddr_in6 my_addr;
 
     if ((sd = socket(AF_INET6, SOCK_STREAM, 0)) == -1) 
         return -1;
 
     my_addr.sin6_family = AF_INET6;
     my_addr.sin6_port = htons(port);
-
-    if (address == NULL)
-        my_addr.sin6_addr = in6addr_any;
-    else 
-        inet_pton(AF_INET6, address, &my_addr.sin6_addr);
+    my_addr.sin6_addr.s_addr = address == NULL ? 
+                        INADDR_ANY : iinet_addr(address);
 #endif
 
     setsockopt(sd, SOL_SOCKET, SO_REUSEADDR, &tp, sizeof(tp));
     if (bind(sd, (struct sockaddr *)&my_addr, sizeof(struct sockaddr)) == -1)
     {
         close(sd);
         return -1;
     }
 
     listen(sd, BACKLOG);
     return sd;
 }
 
 /* Wrapper function for strncpy() that guarantees
    a null-terminated string. This is to avoid any possible
    issues due to strncpy()'s behaviour.
  */
 char *my_strncpy(char *dest, const char *src, size_t n) 
 {
     strncpy(dest, src, n);
     dest[n-1] = '\0';
     return dest;
 }
 
 int isdir(const char *tpbuf) 
 {
     struct stat st;
     char path[MAXREQUESTLENGTH];
     strcpy(path, tpbuf);
 
 #ifdef WIN32        /* win32 stat() can't handle trailing '\' */
     if (path[strlen(path)-1] == '\\')
         path[strlen(path)-1] = 0;
 #endif
 
     if (stat(path, &st) == -1) 
         return 0;
 
     if ((st.st_mode & S_IFMT) == S_IFDIR) 
         return 1;
 
     return 0;
 }
 
 static void addconnection(int sd, char *ip, int is_ssl) 
 {
     struct connstruct *tp;
 
     /* Get ourselves a connstruct */
     if (freeconns == NULL) 
         tp = (struct connstruct *)calloc(1, sizeof(struct connstruct));
     else 
     {
         tp = freeconns;
         freeconns = tp->next;
     }
 
     /* Attach it to the used list */
     tp->next = usedconns;
     usedconns = tp;
     tp->networkdesc = sd;
 
     if (is_ssl)
         tp->ssl = ssl_server_new(servers->ssl_ctx, sd);
 
     tp->is_ssl = is_ssl;
     tp->filedesc = -1;
 #if defined(CONFIG_HTTP_HAS_DIRECTORIES)
     tp->dirp = NULL;
 #endif
     *tp->actualfile = '\0';
     *tp->filereq = '\0';
     tp->state = STATE_WANT_TO_READ_HEAD;
     tp->reqtype = TYPE_GET;
     tp->close_when_done = 0;
     tp->timeout = time(NULL) + CONFIG_HTTP_TIMEOUT;
 #if defined(CONFIG_HTTP_HAS_CGI)
     strcpy(tp->remote_addr, ip);
 #endif
 }
 
 void removeconnection(struct connstruct *cn) 
 {
     struct connstruct *tp;
     int shouldret = 0;
 
     tp = usedconns;
 
     if (tp == NULL || cn == NULL) 
         shouldret = 1;
     else if (tp == cn) 
         usedconns = tp->next;
     else 
     {
         while (tp != NULL) 
         {
             if (tp->next == cn) 
             {
                 tp->next = (tp->next)->next;
                 shouldret = 0;
                 break;
             }
 
             tp = tp->next;
             shouldret = 1;
         }
     }
 
     if (shouldret) 
         return;
 
     /* If we did, add it to the free list */
     cn->next = freeconns;
     freeconns = cn;
 
     /* Close it all down */
     if (cn->networkdesc != -1) 
     {
         if (cn->is_ssl) 
         {
             ssl_free(cn->ssl);
             cn->ssl = NULL;
         }
 
 #ifndef WIN32
         shutdown(cn->networkdesc, SHUT_WR);
 #endif
         SOCKET_CLOSE(cn->networkdesc);
     }
 
     if (cn->filedesc != -1) 
         close(cn->filedesc);
 
 #if defined(CONFIG_HTTP_HAS_DIRECTORIES)
     if (cn->dirp != NULL) 
 #ifdef WIN32
         FindClose(cn->dirp);
 #else
         closedir(cn->dirp);
 #endif
 #endif
 }
 
 /*
  * Change directories one way or the other.
  */
 
 static void ax_chdir(void)
 {
     if (chdir(webroot))
     {
 #ifdef CONFIG_HTTP_VERBOSE
         fprintf(stderr, "'%s' is not a directory\n", webroot);
 #endif
         exit(1);
     }
 }
 
Index: httpd/htpasswd.c
===================================================================
--- httpd/htpasswd.c	(revision 226)
+++ httpd/htpasswd.c	(revision 225)
@@ -1,137 +1,137 @@
 /*
  * Copyright (c) Cameron Rich
  * 
  * All rights reserved.
  * 
  * Redistribution and use in source and binary forms, with or without 
  * modification, are permitted provided that the following conditions are met:
  *
  * * Redistributions of source code must retain the above copyright notice, 
  *   this list of conditions and the following disclaimer.
  * * Redistributions in binary form must reproduce the above copyright notice, 
  *   this list of conditions and the following disclaimer in the documentation 
  *   and/or other materials provided with the distribution.
  * * Neither the name of the axTLS project nor the names of its contributors 
  *   may be used to endorse or promote products derived from this software 
  *   without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
 #include "os_port.h"
 #include "ssl.h"
 
 int tfd;
 
 void base64_encode(const uint8_t *in, size_t inlen, char *out, size_t outlen)
 {
     static const char b64str[64] =
             "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
 
     while (inlen && outlen)
     {
         *out++ = b64str[(in[0] >> 2) & 0x3f];
         if (!--outlen)
             break;
 
         *out++ = b64str[((in[0] << 4)
                 + (--inlen ? in[1] >> 4 : 0)) & 0x3f];
         if (!--outlen)
             break;
         *out++ = (inlen
              ? b64str[((in[1] << 2)
                  + (--inlen ? in[2] >> 6 : 0))
              & 0x3f]
              : '=');
         if (!--outlen)
             break;
         *out++ = inlen ? b64str[in[2] & 0x3f] : '=';
         if (!--outlen)
             break;
         if (inlen)
             inlen--;
         if (inlen)
             in += 3;
     }
 
     if (outlen)
         *out = '\0';
 }
 
 static void usage(void) 
 {
     fprintf(stderr,"Usage: htpasswd username\n");
     exit(1);
 }
 
 #ifdef WIN32
 static char * getpass(const char *prompt)
 {
     static char buf[127];
     FILE *fp = stdin;
 
     printf(prompt); TTY_FLUSH();
 #if 0
     fp = fopen("/dev/tty", "w");
     if (fp == NULL) 
     {
         printf("null\n"); TTY_FLUSH();
         fp = stdin;
     }
 #endif
 
     fgets(buf, sizeof(buf), fp);
     while (buf[strlen(buf)-1] < ' ') 
         buf[strlen(buf)-1] = '\0';
 
     //if (fp != stdin) 
     //    fclose(fp);
     return buf;
 }
 #endif
 
 int main(int argc, char *argv[]) 
 {
     char* pw;
     uint8_t md5_salt[MD5_SIZE], md5_pass[MD5_SIZE];
     char b64_salt[MD5_SIZE+10], b64_pass[MD5_SIZE+10];
     MD5_CTX ctx;
 
     if (argc != 2)
         usage();
 
     pw = strdup(getpass("New password:"));
     if (strcmp(pw, getpass("Re-type new password:")) != 0)
     {
         fprintf(stderr, "They don't match, sorry.\n" );
         exit(1);
     }
 
-    RNG_initialize();
+    RNG_initialize((uint8_t *)pw, sizeof(pw));
     get_random(MD5_SIZE, md5_salt);
     RNG_terminate();
     base64_encode(md5_salt, MD5_SIZE, b64_salt, sizeof(b64_salt));
 
     MD5_Init(&ctx);
     MD5_Update(&ctx, md5_salt, MD5_SIZE);
     MD5_Update(&ctx, (uint8_t *)pw, strlen(pw));
     MD5_Final(md5_pass, &ctx);
     base64_encode(md5_pass, MD5_SIZE, b64_pass, sizeof(b64_pass));
 
     printf("Add the following to your '.htpasswd' file\n");
     printf("%s:%s$%s\n", argv[1], b64_salt, b64_pass);
     return 0;
 }
