r176
Index: ssl/test/ssltest.c
===================================================================
--- ssl/test/ssltest.c	(revision 176)
+++ ssl/test/ssltest.c	(revision 175)
@@ -1,2007 +1,2007 @@
 /*
  * Copyright (c) 2007, Cameron Rich
  * 
  * All rights reserved.
  * 
  * Redistribution and use in source and binary forms, with or without 
  * modification, are permitted provided that the following conditions are met:
  *
  * * Redistributions of source code must retain the above copyright notice, 
  *   this list of conditions and the following disclaimer.
  * * Redistributions in binary form must reproduce the above copyright notice, 
  *   this list of conditions and the following disclaimer in the documentation 
  *   and/or other materials provided with the distribution.
  * * Neither the name of the axTLS project nor the names of its contributors 
  *   may be used to endorse or promote products derived from this software 
  *   without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 /*
  * The testing of the crypto and ssl stuff goes here. Keeps the individual code
  * modules from being uncluttered with test code.
  *
  * This is test code - I make no apologies for the quality!
  */
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <signal.h>
 #include <string.h>
 #include <errno.h>
 #include <sys/stat.h>
 #include <fcntl.h>
 
 #ifndef WIN32
 #include <pthread.h>
 #endif
 
 #include "ssl.h"
 
 #define DEFAULT_CERT            "../ssl/test/axTLS.x509_512.cer"
 #define DEFAULT_KEY             "../ssl/test/axTLS.key_512"     
 //#define DEFAULT_SVR_OPTION      SSL_DISPLAY_BYTES|SSL_DISPLAY_STATES
 #define DEFAULT_SVR_OPTION      0
 //#define DEFAULT_CLNT_OPTION      SSL_DISPLAY_BYTES|SSL_DISPLAY_STATES
 #define DEFAULT_CLNT_OPTION     0
 
 static int g_port = 19001;
 
 /**************************************************************************
  * AES tests 
  * 
  * Run through a couple of the RFC3602 tests to verify that AES is correct.
  **************************************************************************/
 #define TEST1_SIZE  16
 #define TEST2_SIZE  32
 
 static int AES_test(BI_CTX *bi_ctx)
 {
     AES_CTX aes_key;
     int res = 1;
     uint8_t key[TEST1_SIZE];
     uint8_t iv[TEST1_SIZE];
 
     {
         /*
             Case #1: Encrypting 16 bytes (1 block) using AES-CBC
             Key       : 0x06a9214036b8a15b512e03d534120006
             IV        : 0x3dafba429d9eb430b422da802c9fac41
             Plaintext : "Single block msg"
             Ciphertext: 0xe353779c1079aeb82708942dbe77181a
 
         */
         char *in_str =  "Single block msg";
         uint8_t ct[TEST1_SIZE];
         uint8_t enc_data[TEST1_SIZE];
         uint8_t dec_data[TEST1_SIZE];
 
         bigint *key_bi = bi_str_import(
                 bi_ctx, "06A9214036B8A15B512E03D534120006");
         bigint *iv_bi = bi_str_import(
                 bi_ctx, "3DAFBA429D9EB430B422DA802C9FAC41");
         bigint *ct_bi = bi_str_import(
                 bi_ctx, "E353779C1079AEB82708942DBE77181A");
         bi_export(bi_ctx, key_bi, key, TEST1_SIZE);
         bi_export(bi_ctx, iv_bi, iv, TEST1_SIZE);
         bi_export(bi_ctx, ct_bi, ct, TEST1_SIZE);
 
         AES_set_key(&aes_key, key, iv, AES_MODE_128);
         AES_cbc_encrypt(&aes_key, (const uint8_t *)in_str, 
                 enc_data, sizeof(enc_data));
         if (memcmp(enc_data, ct, sizeof(ct)))
         {
             printf("Error: AES ENCRYPT #1 failed\n");
             goto end;
         }
 
         AES_set_key(&aes_key, key, iv, AES_MODE_128);
         AES_convert_key(&aes_key);
         AES_cbc_decrypt(&aes_key, enc_data, dec_data, sizeof(enc_data));
 
         if (memcmp(dec_data, in_str, sizeof(dec_data)))
         {
             printf("Error: AES DECRYPT #1 failed\n");
             goto end;
         }
     }
 
     {
         /*
             Case #2: Encrypting 32 bytes (2 blocks) using AES-CBC 
             Key       : 0xc286696d887c9aa0611bbb3e2025a45a
             IV        : 0x562e17996d093d28ddb3ba695a2e6f58
             Plaintext : 0x000102030405060708090a0b0c0d0e0f
                           101112131415161718191a1b1c1d1e1f
             Ciphertext: 0xd296cd94c2cccf8a3a863028b5e1dc0a
                           7586602d253cfff91b8266bea6d61ab1
         */
         uint8_t in_data[TEST2_SIZE];
         uint8_t ct[TEST2_SIZE];
         uint8_t enc_data[TEST2_SIZE];
         uint8_t dec_data[TEST2_SIZE];
 
         bigint *in_bi = bi_str_import(bi_ctx,
             "000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F");
         bigint *key_bi = bi_str_import(
                 bi_ctx, "C286696D887C9AA0611BBB3E2025A45A");
         bigint *iv_bi = bi_str_import(
                 bi_ctx, "562E17996D093D28DDB3BA695A2E6F58");
         bigint *ct_bi = bi_str_import(bi_ctx,
             "D296CD94C2CCCF8A3A863028B5E1DC0A7586602D253CFFF91B8266BEA6D61AB1");
         bi_export(bi_ctx, in_bi, in_data, TEST2_SIZE);
         bi_export(bi_ctx, key_bi, key, TEST1_SIZE);
         bi_export(bi_ctx, iv_bi, iv, TEST1_SIZE);
         bi_export(bi_ctx, ct_bi, ct, TEST2_SIZE);
 
         AES_set_key(&aes_key, key, iv, AES_MODE_128);
         AES_cbc_encrypt(&aes_key, (const uint8_t *)in_data, 
                 enc_data, sizeof(enc_data));
 
         if (memcmp(enc_data, ct, sizeof(ct)))
         {
             printf("Error: ENCRYPT #2 failed\n");
             goto end;
         }
 
         AES_set_key(&aes_key, key, iv, AES_MODE_128);
         AES_convert_key(&aes_key);
         AES_cbc_decrypt(&aes_key, enc_data, dec_data, sizeof(enc_data));
         if (memcmp(dec_data, in_data, sizeof(dec_data)))
         {
             printf("Error: DECRYPT #2 failed\n");
             goto end;
         }
     }
 
     res = 0;
     printf("All AES tests passed\n");
 
 end:
     return res;
 }
 
 /**************************************************************************
  * RC4 tests 
  *
  * ARC4 tests vectors from OpenSSL (crypto/rc4/rc4test.c)
  **************************************************************************/
 static const uint8_t keys[7][30]=
 {
     {8,0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef},
     {8,0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef},
     {8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
     {4,0xef,0x01,0x23,0x45},
     {8,0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef},
     {4,0xef,0x01,0x23,0x45},
 };
 
 static const uint8_t data_len[7]={8,8,8,20,28,10};
 static uint8_t data[7][30]=
 {
     {0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xff},
     {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff},
     {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff},
     {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
         0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
         0x00,0x00,0x00,0x00,0xff},
         {0x12,0x34,0x56,0x78,0x9A,0xBC,0xDE,0xF0,
             0x12,0x34,0x56,0x78,0x9A,0xBC,0xDE,0xF0,
             0x12,0x34,0x56,0x78,0x9A,0xBC,0xDE,0xF0,
             0x12,0x34,0x56,0x78,0xff},
             {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff},
             {0},
 };
 
 static const uint8_t output[7][30]=
 {
     {0x75,0xb7,0x87,0x80,0x99,0xe0,0xc5,0x96,0x00},
     {0x74,0x94,0xc2,0xe7,0x10,0x4b,0x08,0x79,0x00},
     {0xde,0x18,0x89,0x41,0xa3,0x37,0x5d,0x3a,0x00},
     {0xd6,0xa1,0x41,0xa7,0xec,0x3c,0x38,0xdf,
         0xbd,0x61,0x5a,0x11,0x62,0xe1,0xc7,0xba,
         0x36,0xb6,0x78,0x58,0x00},
         {0x66,0xa0,0x94,0x9f,0x8a,0xf7,0xd6,0x89,
             0x1f,0x7f,0x83,0x2b,0xa8,0x33,0xc0,0x0c,
             0x89,0x2e,0xbe,0x30,0x14,0x3c,0xe2,0x87,
             0x40,0x01,0x1e,0xcf,0x00},
             {0xd6,0xa1,0x41,0xa7,0xec,0x3c,0x38,0xdf,0xbd,0x61,0x00},
             {0},
 };
 
 static int RC4_test(BI_CTX *bi_ctx)
 {
     int i, res = 1;
     RC4_CTX s;
 
     for (i = 0; i < 6; i++)
     {
         RC4_setup(&s, &keys[i][1], keys[i][0]);
         RC4_crypt(&s, data[i], data[i], data_len[i]);
 
         if (memcmp(data[i], output[i], data_len[i]))
         {
             printf("Error: RC4 CRYPT #%d failed\n", i);
             goto end;
         }
     }
 
     res = 0;
     printf("All RC4 tests passed\n");
 
 end:
     return res;
 }
 
 /**************************************************************************
  * SHA1 tests 
  *
  * Run through a couple of the RFC3174 tests to verify that SHA1 is correct.
  **************************************************************************/
 static int SHA1_test(BI_CTX *bi_ctx)
 {
     SHA1_CTX ctx;
     uint8_t ct[SHA1_SIZE];
     uint8_t digest[SHA1_SIZE];
     int res = 1;
 
     {
         const char *in_str = "abc";
         bigint *ct_bi = bi_str_import(bi_ctx,
                 "A9993E364706816ABA3E25717850C26C9CD0D89D");
         bi_export(bi_ctx, ct_bi, ct, SHA1_SIZE);
 
         SHA1_Init(&ctx);
         SHA1_Update(&ctx, (const uint8_t *)in_str, strlen(in_str));
         SHA1_Final(digest, &ctx);
 
         if (memcmp(digest, ct, sizeof(ct)))
         {
             printf("Error: SHA1 #1 failed\n");
             goto end;
         }
     }
 
     {
         const char *in_str =
             "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq";
         bigint *ct_bi = bi_str_import(bi_ctx,
                 "84983E441C3BD26EBAAE4AA1F95129E5E54670F1");
         bi_export(bi_ctx, ct_bi, ct, SHA1_SIZE);
 
         SHA1_Init(&ctx);
         SHA1_Update(&ctx, (const uint8_t *)in_str, strlen(in_str));
         SHA1_Final(digest, &ctx);
 
         if (memcmp(digest, ct, sizeof(ct)))
         {
             printf("Error: SHA1 #2 failed\n");
             goto end;
         }
     }
 
     res = 0;
     printf("All SHA1 tests passed\n");
 
 end:
     return res;
 }
 
 /**************************************************************************
  * MD5 tests 
  *
  * Run through a couple of the RFC1321 tests to verify that MD5 is correct.
  **************************************************************************/
 static int MD5_test(BI_CTX *bi_ctx)
 {
     MD5_CTX ctx;
     uint8_t ct[MD5_SIZE];
     uint8_t digest[MD5_SIZE];
     int res = 1;
 
     {
         const char *in_str =  "abc";
         bigint *ct_bi = bi_str_import(bi_ctx, 
                 "900150983CD24FB0D6963F7D28E17F72");
         bi_export(bi_ctx, ct_bi, ct, MD5_SIZE);
 
         MD5_Init(&ctx);
         MD5_Update(&ctx, (const uint8_t *)in_str, strlen(in_str));
         MD5_Final(digest, &ctx);
 
         if (memcmp(digest, ct, sizeof(ct)))
         {
             printf("Error: MD5 #1 failed\n");
             goto end;
         }
     }
 
     {
         const char *in_str =
             "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
         bigint *ct_bi = bi_str_import(
                 bi_ctx, "D174AB98D277D9F5A5611C2C9F419D9F");
         bi_export(bi_ctx, ct_bi, ct, MD5_SIZE);
 
         MD5_Init(&ctx);
         MD5_Update(&ctx, (const uint8_t *)in_str, strlen(in_str));
         MD5_Final(digest, &ctx);
 
         if (memcmp(digest, ct, sizeof(ct)))
         {
             printf("Error: MD5 #2 failed\n");
             goto end;
         }
     }
     res = 0;
     printf("All MD5 tests passed\n");
 
 end:
     return res;
 }
 
 /**************************************************************************
  * HMAC tests 
  *
  * Run through a couple of the RFC2202 tests to verify that HMAC is correct.
  **************************************************************************/
 static int HMAC_test(BI_CTX *bi_ctx)
 {
     uint8_t key[SHA1_SIZE];
     uint8_t ct[SHA1_SIZE];
     uint8_t dgst[SHA1_SIZE];
     int res = 1;
     const char *key_str;
 
     const char *data_str = "Hi There";
     bigint *key_bi = bi_str_import(bi_ctx, "0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B");
     bigint *ct_bi = bi_str_import(bi_ctx, "9294727A3638BB1C13F48EF8158BFC9D");
     bi_export(bi_ctx, key_bi, key, MD5_SIZE);
     bi_export(bi_ctx, ct_bi, ct, MD5_SIZE);
     hmac_md5((const uint8_t *)data_str, 8, key, MD5_SIZE, dgst);
     if (memcmp(dgst, ct, MD5_SIZE))
     {
         printf("HMAC MD5 #1 failed\n");
         goto end;
     }
 
     data_str = "what do ya want for nothing?";
     key_str = "Jefe";
     ct_bi = bi_str_import(bi_ctx, "750C783E6AB0B503EAA86E310A5DB738");
     bi_export(bi_ctx, ct_bi, ct, MD5_SIZE);
     hmac_md5((const uint8_t *)data_str, 28, (const uint8_t *)key_str, 4, dgst);
     if (memcmp(dgst, ct, MD5_SIZE))
     {
         printf("HMAC MD5 #2 failed\n");
         goto end;
     }
    
     data_str = "Hi There";
     key_bi = bi_str_import(bi_ctx, "0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B");
     bi_export(bi_ctx, key_bi, key, SHA1_SIZE);
     ct_bi = bi_str_import(bi_ctx, "B617318655057264E28BC0B6FB378C8EF146BE00");
     bi_export(bi_ctx, ct_bi, ct, SHA1_SIZE);
 
     hmac_sha1((const uint8_t *)data_str, 8, 
             (const uint8_t *)key, SHA1_SIZE, dgst);
     if (memcmp(dgst, ct, SHA1_SIZE))
     {
         printf("HMAC SHA1 #1 failed\n");
         goto end;
     }
 
     data_str = "what do ya want for nothing?";
     key_str = "Jefe";
     ct_bi = bi_str_import(bi_ctx, "EFFCDF6AE5EB2FA2D27416D5F184DF9C259A7C79");
     bi_export(bi_ctx, ct_bi, ct, SHA1_SIZE);
 
     hmac_sha1((const uint8_t *)data_str, 28, (const uint8_t *)key_str, 5, dgst);
     if (memcmp(dgst, ct, SHA1_SIZE))
     {
         printf("HMAC SHA1 failed\n");
         exit(1);
     }
 
     res = 0;
     printf("All HMAC tests passed\n");
 
 end:
     return res;
 }
 
 /**************************************************************************
  * BIGINT tests 
  *
  **************************************************************************/
 static int BIGINT_test(BI_CTX *ctx)
 {
     int res = 1;
     bigint *bi_data, *bi_exp, *bi_res;
     const char *expnt, *plaintext, *mod;
     uint8_t compare[MAX_KEY_BYTE_SIZE];
 
     /**
      * 512 bit key
      */
     plaintext = /* 64 byte number */
         "01aaaaaaaaaabbbbbbbbbbbbbbbccccccccccccccdddddddddddddeeeeeeeeee";
 
     mod = "C30773C8ABE09FCC279EE0E5343370DE"
           "8B2FFDB6059271E3005A7CEEF0D35E0A"
           "1F9915D95E63560836CC2EB2C289270D"
           "BCAE8CAF6F5E907FC2759EE220071E1B";
 
     expnt = "A1E556CD1738E10DF539E35101334E97"
           "BE8D391C57A5C89A7AD9A2EA2ACA1B3D"
           "F3140F5091CC535CBAA47CEC4159EE1F"
           "B6A3661AFF1AB758426EAB158452A9B9";
 
     bi_data = bi_import(ctx, (uint8_t *)plaintext, strlen(plaintext));
     bi_exp = int_to_bi(ctx, 0x10001);
     bi_set_mod(ctx, bi_str_import(ctx, mod), 0);
     bi_res = bi_mod_power(ctx, bi_data, bi_exp);
 
     bi_data = bi_res;   /* resuse again - see if we get the original */
 
     bi_exp = bi_str_import(ctx, expnt);
     bi_res = bi_mod_power(ctx, bi_data, bi_exp);
     bi_free_mod(ctx, 0);
 
     bi_export(ctx, bi_res, compare, 64);
     if (memcmp(plaintext, compare, 64) != 0)
         goto end;
 
     printf("All BIGINT tests passed\n");
     res = 0;
 
 end:
     return res;
 }
 
 /**************************************************************************
  * RSA tests 
  *
  * Use the results from openssl to verify PKCS1 etc 
  **************************************************************************/
 static int RSA_test(void)
 {
     int res = 1;
     const char *plaintext = /* 128 byte hex number */
         "1aaaaaaaaaabbbbbbbbbbbbbbbccccccccccccccdddddddddddddeeeeeeeeee2"
         "1aaaaaaaaaabbbbbbbbbbbbbbbccccccccccccccdddddddddddddeeeeeeeee2\012";
     uint8_t enc_data[128], dec_data[128];
     RSA_CTX *rsa_ctx = NULL;
     BI_CTX *bi_ctx;
     bigint *plaintext_bi;
     bigint *enc_data_bi, *dec_data_bi;
     uint8_t enc_data2[128], dec_data2[128];
     int size;
     int len; 
     uint8_t *buf;
 
     /* extract the private key elements */
     len = get_file("../ssl/test/axTLS.key_1024", &buf);
     if (asn1_get_private_key(buf, len, &rsa_ctx) < 0)
     {
         goto end;
     }
 
     free(buf);
     bi_ctx = rsa_ctx->bi_ctx;
     plaintext_bi = bi_import(bi_ctx, 
             (const uint8_t *)plaintext, strlen(plaintext));
 
     /* basic rsa encrypt */
     enc_data_bi = RSA_public(rsa_ctx, plaintext_bi);
     bi_export(bi_ctx, bi_copy(enc_data_bi), enc_data, sizeof(enc_data));
 
     /* basic rsa decrypt */
     dec_data_bi = RSA_private(rsa_ctx, enc_data_bi);
     bi_export(bi_ctx, dec_data_bi, dec_data, sizeof(dec_data));
 
     if (memcmp(dec_data, plaintext, strlen(plaintext)))
     {
         printf("Error: DECRYPT #1 failed\n");
         goto end;
     }
 
     RSA_encrypt(rsa_ctx, (const uint8_t *)"abc", 3, enc_data2, 0);
     size = RSA_decrypt(rsa_ctx, enc_data2, dec_data2, 1);
     if (memcmp("abc", dec_data2, 3))
     {
         printf("Error: ENCRYPT/DECRYPT #2 failed\n");
         goto end;
     }
 
     RSA_free(rsa_ctx);
     res = 0;
     printf("All RSA tests passed\n");
 
 end:
     return res;
 }
 
 /**************************************************************************
  * Cert Testing
  *
  **************************************************************************/
 static int cert_tests(void)
 {
     int res = -1, len;
     X509_CTX *x509_ctx;
     SSL_CTX *ssl_ctx;
     uint8_t *buf;
 
     /* check a bunch of 3rd party certificates */
     ssl_ctx = ssl_ctx_new(0, 0);
     len = get_file("../ssl/test/microsoft.x509_ca", &buf);
     if ((res = add_cert_auth(ssl_ctx, buf, len)) < 0)
     {
         printf("Cert #1\n");
         ssl_display_error(res);
         goto bad_cert;
     }
 
     ssl_ctx_free(ssl_ctx);
     free(buf);
 
     ssl_ctx = ssl_ctx_new(0, 0);
     len = get_file("../ssl/test/thawte.x509_ca", &buf);
     if ((res = add_cert_auth(ssl_ctx, buf, len)) < 0)
     {
         printf("Cert #2\n");
         ssl_display_error(res);
         goto bad_cert;
     }
 
     ssl_ctx_free(ssl_ctx);
     free(buf);
 
     ssl_ctx = ssl_ctx_new(0, 0);
     len = get_file("../ssl/test/deutsche_telecom.x509_ca", &buf);
     if ((res = add_cert_auth(ssl_ctx, buf, len)) < 0)
     {
         printf("Cert #3\n");
         ssl_display_error(res);
         goto bad_cert;
     }
 
     ssl_ctx_free(ssl_ctx);
     free(buf);
 
     ssl_ctx = ssl_ctx_new(0, 0);
     len = get_file("../ssl/test/equifax.x509_ca", &buf);
     if ((res = add_cert_auth(ssl_ctx, buf, len)) < 0)
     {
         printf("Cert #4\n");
         ssl_display_error(res);
         goto bad_cert;
     }
 
     ssl_ctx_free(ssl_ctx);
     free(buf);
 
     ssl_ctx = ssl_ctx_new(0, 0);
     len = get_file("../ssl/test/gnutls.cer", &buf);
     if ((res = add_cert(ssl_ctx, buf, len)) < 0)
     {
         printf("Cert #5\n");
         ssl_display_error(res);
         goto bad_cert;
     }
 
     ssl_ctx_free(ssl_ctx);
     free(buf);
 
     ssl_ctx = ssl_ctx_new(0, 0);
     len = get_file("../ssl/test/socgen.cer", &buf);
     if ((res = add_cert(ssl_ctx, buf, len)) < 0)
     {
         printf("Cert #6\n");
         ssl_display_error(res);
         goto bad_cert;
     }
 
     ssl_ctx_free(ssl_ctx);
     free(buf);
 
     ssl_ctx = ssl_ctx_new(0, 0);
     len = get_file("../ssl/test/verisign.x509_ca", &buf);
     if ((res = add_cert_auth(ssl_ctx, buf, len)) <0)
     {
         printf("Cert #7\n");
         ssl_display_error(res);
         goto bad_cert;
     }
 
     ssl_ctx_free(ssl_ctx);
     free(buf);
 
     if (get_file("../ssl/test/verisign.x509_my_cert", &buf) < 0 ||
                                     x509_new(buf, &len, &x509_ctx))
     {
         printf("Cert #8\n");
         ssl_display_error(res);
         goto bad_cert;
     }
 
     x509_free(x509_ctx);
     free(buf);
 
     ssl_ctx = ssl_ctx_new(0, 0);
     if ((res = ssl_obj_load(ssl_ctx, 
               SSL_OBJ_X509_CERT, "../ssl/test/ms_iis.cer", NULL)) != SSL_OK)
     {
         ssl_display_error(res);
         goto bad_cert;
     }
 
     ssl_ctx_free(ssl_ctx);
 
     if (get_file("../ssl/test/qualityssl.com.der", &buf) < 0 ||
                                     x509_new(buf, &len, &x509_ctx))
     {
         printf("Cert #9\n");
         res = -1;
         goto bad_cert;
     }
 
     if (strcmp(x509_ctx->subject_alt_dnsnames[1], "qualityssl.com"))
     {
         printf("Cert #9 (2)\n");
         res = -1;
         goto bad_cert;
     }
     x509_free(x509_ctx);
     free(buf);
 
     res = 0;        /* all ok */
     printf("All Certificate tests passed\n");
 
 bad_cert:
     if (res)
         printf("Error: A certificate test failed\n");
     return res;
 }
 
 /**
  * init a server socket.
  */
 static int server_socket_init(int *port)
 {
     struct sockaddr_in serv_addr;
     int server_fd;
     char yes = 1;
 
     /* Create socket for incoming connections */
     if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
     {
         return -1;
     }
       
     setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));
 
 go_again:
     /* Construct local address structure */
     memset(&serv_addr, 0, sizeof(serv_addr));      /* Zero out structure */
     serv_addr.sin_family = AF_INET;                /* Internet address family */
     serv_addr.sin_addr.s_addr = htonl(INADDR_ANY); /* Any incoming interface */
     serv_addr.sin_port = htons(*port);              /* Local port */
 
     /* Bind to the local address */
     if (bind(server_fd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0)
     {
         (*port)++;
         goto go_again;
     }
     /* Mark the socket so it will listen for incoming connections */
     if (listen(server_fd, 3000) < 0)
     {
         return -1;
     }
 
     return server_fd;
 }
 
 /**
  * init a client socket.
  */
 static int client_socket_init(uint16_t port)
 {
     struct sockaddr_in address;
     int client_fd;
 
     address.sin_family = AF_INET;
     address.sin_port = htons(port);
     address.sin_addr.s_addr =  inet_addr("127.0.0.1");
     client_fd = socket(AF_INET, SOCK_STREAM, 0);
     if (connect(client_fd, (struct sockaddr *)&address, sizeof(address)) < 0)
     {
         perror("socket");
         SOCKET_CLOSE(client_fd);
         client_fd = -1;
     }
 
     return client_fd;
 }
 
 /**************************************************************************
  * SSL Server Testing
  *
  **************************************************************************/
 typedef struct
 {
     /* not used as yet */
     int dummy;
 } SVR_CTX;
 
 typedef struct
 {
     const char *testname;
     const char *openssl_option;
 } client_t;
 
 static void do_client(client_t *clnt)
 {
     char openssl_buf[2048];
 
     /* make sure the main thread goes first */
     sleep(0);
 
     /* show the session ids in the reconnect test */
     if (strcmp(clnt->testname, "Session Reuse") == 0)
     {
         sprintf(openssl_buf, "echo \"hello client\" | openssl s_client "
             "-connect localhost:%d %s 2>&1 | grep \"Session-ID:\"", 
             g_port, clnt->openssl_option);
     }
     else
     {
         sprintf(openssl_buf, "echo \"hello client\" | openssl s_client "
 #ifdef WIN32
             "-connect localhost:%d -quiet %s",
 #else
             "-connect localhost:%d -quiet %s > /dev/null 2>&1",
 #endif
         g_port, clnt->openssl_option);
     }
 
     system(openssl_buf);
 }
 
 static int SSL_server_test(
         const char *testname, 
         const char *openssl_option, 
         const char *device_cert, 
         const char *product_cert, 
         const char *private_key,
         const char *ca_cert,
         const char *password,
         int axtls_option)
 {
     int server_fd, ret = 0;
     SSL_CTX *ssl_ctx = NULL;
     struct sockaddr_in client_addr;
     uint8_t *read_buf;
     socklen_t clnt_len = sizeof(client_addr);
     client_t client_data;
 #ifndef WIN32
     pthread_t thread;
 #endif
     g_port++;
 
     client_data.testname = testname;
     client_data.openssl_option = openssl_option;
 
     if ((server_fd = server_socket_init(&g_port)) < 0)
         goto error;
 
     if (private_key)
     {
         axtls_option |= SSL_NO_DEFAULT_KEY;
     }
 
     if ((ssl_ctx = ssl_ctx_new(axtls_option, SSL_DEFAULT_SVR_SESS)) == NULL)
     {
         ret = SSL_ERROR_INVALID_KEY;
         goto error;
     }
 
     if (private_key)
     {
         int obj_type = SSL_OBJ_RSA_KEY;
 
         if (strstr(private_key, ".p8"))
             obj_type = SSL_OBJ_PKCS8;
         else if (strstr(private_key, ".p12"))
             obj_type = SSL_OBJ_PKCS12;
 
         if (ssl_obj_load(ssl_ctx, obj_type, private_key, password))
         {
             ret = SSL_ERROR_INVALID_KEY;
             goto error;
         }
     }
 
     if (device_cert)             /* test chaining */
     {
         if ((ret = ssl_obj_load(ssl_ctx, 
                         SSL_OBJ_X509_CERT, device_cert, NULL)) != SSL_OK)
             goto error;
     }
 
     if (product_cert)             /* test chaining */
     {
         if ((ret = ssl_obj_load(ssl_ctx, 
                         SSL_OBJ_X509_CERT, product_cert, NULL)) != SSL_OK)
             goto error;
     }
 
     if (ca_cert)                  /* test adding certificate authorities */
     {
         if ((ret = ssl_obj_load(ssl_ctx, 
                         SSL_OBJ_X509_CACERT, ca_cert, NULL)) != SSL_OK)
             goto error;
     }
 
 #ifndef WIN32
     pthread_create(&thread, NULL, 
                 (void *(*)(void *))do_client, (void *)&client_data);
     pthread_detach(thread);
 #else
     CreateThread(NULL, 1024, (LPTHREAD_START_ROUTINE)do_client, 
             (LPVOID)&client_data, 0, NULL);
 #endif
 
     for (;;)
     {
         int client_fd, size = 0; 
         SSL *ssl;
 
         /* Wait for a client to connect */
         if ((client_fd = accept(server_fd, 
                         (struct sockaddr *)&client_addr, &clnt_len)) < 0)
         {
             ret = SSL_ERROR_SOCK_SETUP_FAILURE;
             goto error;
         }
         
         /* we are ready to go */
         ssl = ssl_server_new(ssl_ctx, client_fd);
         while ((size = ssl_read(ssl, &read_buf)) == SSL_OK);
         SOCKET_CLOSE(client_fd);
         
         if (size < SSL_OK) /* got some alert or something nasty */
         {
             ret = size;
 
             if (ret == SSL_ERROR_CONN_LOST)
             {
                 ret = SSL_OK;
                 continue;
             }
 
             break;  /* we've got a problem */
         }
         else /* looks more promising */
         {
             if (strstr("hello client", (char *)read_buf) == NULL)
             {
                 printf("SSL server test \"%s\" passed\n", testname);
                 TTY_FLUSH();
                 ret = 0;
                 break;
             }
         }
 
         ssl_free(ssl);
     }
 
     SOCKET_CLOSE(server_fd);
 
 error:
     ssl_ctx_free(ssl_ctx);
     return ret;
 }
 
 int SSL_server_tests(void)
 {
     int ret = -1;
     struct stat stat_buf;
     SVR_CTX svr_test_ctx;
     memset(&svr_test_ctx, 0, sizeof(SVR_CTX));
 
     printf("### starting server tests\n"); TTY_FLUSH();
 
     /* Go through the algorithms */
 
     /* 
      * TLS1 client hello 
      */
     if ((ret = SSL_server_test("TLSv1", "-cipher RC4-SHA -tls1", 
                     NULL, NULL, NULL, NULL, NULL, DEFAULT_SVR_OPTION)))
         goto cleanup;
 
     /*
      * AES128-SHA
      */
     if ((ret = SSL_server_test("AES256-SHA", "-cipher AES128-SHA", 
                     DEFAULT_CERT, NULL, DEFAULT_KEY, NULL, NULL,
                     DEFAULT_SVR_OPTION)))
         goto cleanup;
 
     /*
      * AES256-SHA
      */
     if ((ret = SSL_server_test("AES256-SHA", "-cipher AES128-SHA", 
                     DEFAULT_CERT, NULL, DEFAULT_KEY, NULL, NULL,
                     DEFAULT_SVR_OPTION)))
         goto cleanup;
 
     /*
      * RC4-SHA
      */
     if ((ret = SSL_server_test("RC4-SHA", "-cipher RC4-SHA", 
                 DEFAULT_CERT, NULL, DEFAULT_KEY, NULL, NULL,
                 DEFAULT_SVR_OPTION)))
         goto cleanup;
 
     /*
      * RC4-MD5
      */
     if ((ret = SSL_server_test("RC4-MD5", "-cipher RC4-MD5", 
                 DEFAULT_CERT, NULL, DEFAULT_KEY, NULL, NULL,
                 DEFAULT_SVR_OPTION)))
         goto cleanup;
 
     /*
      * Session Reuse
      * all the session id's should match for session resumption.
      */
     if ((ret = SSL_server_test("Session Reuse", 
                     "-cipher RC4-SHA -reconnect", 
                     DEFAULT_CERT, NULL, DEFAULT_KEY, NULL, NULL,
                     DEFAULT_SVR_OPTION)))
         goto cleanup;
 
     /* 
      * 512 bit RSA key 
      */
     if ((ret = SSL_server_test("512 bit key", "-cipher RC4-SHA", 
                     "../ssl/test/axTLS.x509_512.cer", NULL, 
                     "../ssl/test/axTLS.key_512",
                     NULL, NULL, DEFAULT_SVR_OPTION)))
         goto cleanup;
 
     /* 
      * 1024 bit RSA key (check certificate chaining)
      */
     if ((ret = SSL_server_test("1024 bit key", 
                     "-cipher RC4-SHA", 
                     "../ssl/test/axTLS.x509_device.cer", 
                     "../ssl/test/axTLS.x509_512.cer", 
                     "../ssl/test/axTLS.device_key",
                     NULL, NULL, DEFAULT_SVR_OPTION)))
         goto cleanup;
 
     /* 
      * 2048 bit RSA key 
      */
     if ((ret = SSL_server_test("2048 bit key", 
                     "-cipher RC4-SHA",
                     "../ssl/test/axTLS.x509_2048.cer", NULL, 
                     "../ssl/test/axTLS.key_2048",
                     NULL, NULL, DEFAULT_SVR_OPTION)))
         goto cleanup;
 
     /* 
      * 4096 bit RSA key 
      */
     if ((ret = SSL_server_test("4096 bit key", 
                     "-cipher RC4-SHA",
                     "../ssl/test/axTLS.x509_4096.cer", NULL, 
                     "../ssl/test/axTLS.key_4096",
                     NULL, NULL, DEFAULT_SVR_OPTION)))
         goto cleanup;
 
     /* 
      * Client Verification
      */
     if ((ret = SSL_server_test("Client Verification", 
                     "-cipher RC4-SHA -tls1 "
                     "-cert ../ssl/test/axTLS.x509_2048.pem "
                     "-key ../ssl/test/axTLS.key_2048.pem ",
                     NULL, NULL, NULL, 
                     "../ssl/test/axTLS.ca_x509.cer", NULL,
                     DEFAULT_SVR_OPTION|SSL_CLIENT_AUTHENTICATION)))
         goto cleanup;
 
     /* this test should fail */
     if (stat("../ssl/test/axTLS.x509_bad_before.pem", &stat_buf) >= 0)
     {
         if ((ret = SSL_server_test("Error: Bad Before Cert", 
                     "-cipher RC4-SHA -tls1 "
                     "-cert ../ssl/test/axTLS.x509_bad_before.pem "
                     "-key ../ssl/test/axTLS.key_512.pem ",
                     NULL, NULL, NULL, 
                     "../ssl/test/axTLS.ca_x509.cer", NULL,
                     DEFAULT_SVR_OPTION|SSL_CLIENT_AUTHENTICATION)) !=
                             SSL_X509_ERROR(X509_VFY_ERROR_NOT_YET_VALID))
             goto cleanup;
 
         printf("SSL server test \"%s\" passed\n", "Bad Before Cert");
         TTY_FLUSH();
         ret = 0;    /* is ok */
     }
 
     /* this test should fail */
     if ((ret = SSL_server_test("Error: Bad After Cert", 
                     "-cipher RC4-SHA -tls1 "
                     "-cert ../ssl/test/axTLS.x509_bad_after.pem "
                     "-key ../ssl/test/axTLS.key_512.pem ",
                     NULL, NULL, NULL, 
                     "../ssl/test/axTLS.ca_x509.cer", NULL,
                     DEFAULT_SVR_OPTION|SSL_CLIENT_AUTHENTICATION)) !=
                             SSL_X509_ERROR(X509_VFY_ERROR_EXPIRED))
         goto cleanup;
 
     printf("SSL server test \"%s\" passed\n", "Bad After Cert");
     TTY_FLUSH();
 
     /*
      * No trusted cert
      */
     if ((ret = SSL_server_test("Error: No trusted certificate", 
                     "-cipher RC4-SHA -tls1 "
                     "-cert ../ssl/test/axTLS.x509_512.pem "
                     "-key ../ssl/test/axTLS.key_512.pem ",
                     NULL, NULL, NULL, 
                     NULL, NULL,
                     DEFAULT_SVR_OPTION|SSL_CLIENT_AUTHENTICATION)) !=
                             SSL_X509_ERROR(X509_VFY_ERROR_NO_TRUSTED_CERT))
         goto cleanup;
 
     printf("SSL server test \"%s\" passed\n", "No trusted certificate");
     TTY_FLUSH();
 
     /*
      * Self-signed (from the server)
      */
     if ((ret = SSL_server_test("Error: Self-signed certificate (from server)", 
                     "-cipher RC4-SHA -tls1 "
                     "-cert ../ssl/test/axTLS.x509_512.pem "
                     "-key ../ssl/test/axTLS.key_512.pem "
                     "-CAfile ../ssl/test/axTLS.ca_x509.pem ",
                     NULL, NULL, NULL, 
                     NULL, NULL,
                     DEFAULT_SVR_OPTION|SSL_CLIENT_AUTHENTICATION)) !=
                             SSL_X509_ERROR(X509_VFY_ERROR_SELF_SIGNED))
         goto cleanup;
 
     printf("SSL server test \"%s\" passed\n", 
                             "Self-signed certificate (from server)");
     TTY_FLUSH();
 
     /*
      * Self-signed (from the client)
      */
     if ((ret = SSL_server_test("Self-signed certificate (from client)", 
                     "-cipher RC4-SHA -tls1 "
                     "-cert ../ssl/test/axTLS.x509_512.pem "
                     "-key ../ssl/test/axTLS.key_512.pem ",
                     NULL, NULL, NULL, 
                     "../ssl/test/axTLS.ca_x509.cer",
                     NULL,
                     DEFAULT_SVR_OPTION|SSL_CLIENT_AUTHENTICATION)))
         goto cleanup;
 
     /* 
      * Key in PEM format
      */
     if ((ret = SSL_server_test("Key in PEM format",
                     "-cipher RC4-SHA", 
                     "../ssl/test/axTLS.x509_512.cer", NULL, 
                     "../ssl/test/axTLS.key_512.pem", NULL,
                     NULL, DEFAULT_SVR_OPTION)))
         goto cleanup;
 
     /* 
      * Cert in PEM format
      */
     if ((ret = SSL_server_test("Cert in PEM format", 
                     "-cipher RC4-SHA", 
                     "../ssl/test/axTLS.x509_512.pem", NULL, 
                     "../ssl/test/axTLS.key_512.pem", NULL,
                     NULL, DEFAULT_SVR_OPTION)))
         goto cleanup;
 
     /* 
      * Cert chain in PEM format
      */
     if ((ret = SSL_server_test("Cert chain in PEM format", 
                     "-cipher RC4-SHA", 
                     "../ssl/test/axTLS.x509_device.pem", 
                     NULL, "../ssl/test/axTLS.device_key.pem",
                     "../ssl/test/axTLS.ca_x509.pem", NULL, DEFAULT_SVR_OPTION)))
         goto cleanup;
 
     /* 
      * AES128 Encrypted key 
      */
     if ((ret = SSL_server_test("AES128 encrypted key", 
                     "-cipher RC4-SHA", 
                     "../ssl/test/axTLS.x509_aes128.pem", NULL, 
                     "../ssl/test/axTLS.key_aes128.pem",
                     NULL, "abcd", DEFAULT_SVR_OPTION)))
         goto cleanup;
 
     /* 
      * AES256 Encrypted key 
      */
     if ((ret = SSL_server_test("AES256 encrypted key", 
                     "-cipher RC4-SHA", 
                     "../ssl/test/axTLS.x509_aes256.pem", NULL, 
                     "../ssl/test/axTLS.key_aes256.pem",
                     NULL, "abcd", DEFAULT_SVR_OPTION)))
         goto cleanup;
 
     /* 
      * AES128 Encrypted invalid key 
      */
     if ((ret = SSL_server_test("AES128 encrypted invalid key", 
                     "-cipher RC4-SHA", 
                     "../ssl/test/axTLS.x509_aes128.pem", NULL, 
                     "../ssl/test/axTLS.key_aes128.pem",
                     NULL, "xyz", DEFAULT_SVR_OPTION)) != SSL_ERROR_INVALID_KEY)
         goto cleanup;
 
     printf("SSL server test \"%s\" passed\n", "AES128 encrypted invalid key");
     TTY_FLUSH();
 
     /*
      * PKCS#8 key (encrypted)
      */
     if ((ret = SSL_server_test("pkcs#8 encrypted", "-cipher RC4-SHA", 
                 DEFAULT_CERT, NULL, "../ssl/test/axTLS.encrypted.p8", 
                 NULL, "abcd", DEFAULT_SVR_OPTION)))
         goto cleanup;
 
     /*
      * PKCS#8 key (unencrypted)
      */
     if ((ret = SSL_server_test("pkcs#8 unencrypted", "-cipher RC4-SHA", 
                 DEFAULT_CERT, NULL, "../ssl/test/axTLS.unencrypted.p8", 
                 NULL, NULL, DEFAULT_SVR_OPTION)))
         goto cleanup;
 
     /*
      * PKCS#12 key/certificate
      */
     if ((ret = SSL_server_test("pkcs#12 with CA", "-cipher RC4-SHA", 
                 NULL, NULL, "../ssl/test/axTLS.withCA.p12", 
                 NULL, "abcd", DEFAULT_SVR_OPTION)))
         goto cleanup;
 
     if ((ret = SSL_server_test("pkcs#12 no CA", "-cipher RC4-SHA", 
                 DEFAULT_CERT, NULL, "../ssl/test/axTLS.withoutCA.p12", 
                 NULL, "abcd", DEFAULT_SVR_OPTION)))
         goto cleanup;
 
     ret = 0;
 
 cleanup:
     if (ret)
     {
         printf("Error: A server test failed\n");
         ssl_display_error(ret);
         exit(1);
     }
     else
     {
         printf("All server tests passed\n"); TTY_FLUSH();
     }
 
     return ret;
 }
 
 /**************************************************************************
  * SSL Client Testing
  *
  **************************************************************************/
 typedef struct
 {
     uint8_t session_id[SSL_SESSION_ID_SIZE];
 #ifndef WIN32
     pthread_t server_thread;
 #endif
     int start_server;
     int stop_server;
     int do_reneg;
 } CLNT_SESSION_RESUME_CTX;
 
 typedef struct
 {
     const char *testname;
     const char *openssl_option;
 } server_t;
 
 static void do_server(server_t *svr)
 {
     char openssl_buf[2048];
 #ifndef WIN32
     pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
 #endif
     sprintf(openssl_buf, "openssl s_server -tls1 " 
             "-accept %d -quiet %s ", g_port, svr->openssl_option);
     system(openssl_buf);
 }
 
 static int SSL_client_test(
         const char *test,
         SSL_CTX **ssl_ctx,
         const char *openssl_option, 
         CLNT_SESSION_RESUME_CTX *sess_resume,
         uint32_t client_options,
         const char *private_key,
         const char *password,
         const char *cert)
 {
     server_t server_data;
     SSL *ssl = NULL;
     int client_fd = -1;
     uint8_t *session_id = NULL;
     int ret = 1;
 #ifndef WIN32
     pthread_t thread;
 #endif
 
     if (sess_resume == NULL || sess_resume->start_server)
     {
         g_port++;
         server_data.openssl_option = openssl_option;
 
 #ifndef WIN32
         pthread_create(&thread, NULL, 
                 (void *(*)(void *))do_server, (void *)&server_data);
         pthread_detach(thread);
 #else
         CreateThread(NULL, 1024, (LPTHREAD_START_ROUTINE)do_server, 
             (LPVOID)&server_data, 0, NULL);
 #endif
     }
     
     usleep(500000);           /* allow server to start */
 
     if (*ssl_ctx == NULL)
     {
         if (private_key)
         {
             client_options |= SSL_NO_DEFAULT_KEY;
         }
 
         if ((*ssl_ctx = ssl_ctx_new(
                             client_options, SSL_DEFAULT_CLNT_SESS)) == NULL)
         {
             ret = SSL_ERROR_INVALID_KEY;
             goto client_test_exit;
         }
 
         if (private_key)
         {
             int obj_type = SSL_OBJ_RSA_KEY;
 
             if (strstr(private_key, ".p8"))
                 obj_type = SSL_OBJ_PKCS8;
             else if (strstr(private_key, ".p12"))
                 obj_type = SSL_OBJ_PKCS12;
 
             if (ssl_obj_load(*ssl_ctx, obj_type, private_key, password))
             {
                 ret = SSL_ERROR_INVALID_KEY;
                 goto client_test_exit;
             }
         }
 
         if (cert)                  
         {
             if ((ret = ssl_obj_load(*ssl_ctx, 
                             SSL_OBJ_X509_CERT, cert, NULL)) != SSL_OK)
             {
                 printf("could not add cert %s (%d)\n", cert, ret);
                 TTY_FLUSH();
                 goto client_test_exit;
             }
         }
 
 	if (ssl_obj_load(*ssl_ctx, SSL_OBJ_X509_CACERT, 
 				"../ssl/test/axTLS.ca_x509.cer", NULL))
         {
             printf("could not add cert auth\n"); TTY_FLUSH();
             goto client_test_exit;
         }
     }
     
     if (sess_resume && !sess_resume->start_server) 
     {
         session_id = sess_resume->session_id;
     }
 
     if ((client_fd = client_socket_init(g_port)) < 0)
     {
         printf("could not start socket on %d\n", g_port); TTY_FLUSH();
         goto client_test_exit;
     }
 
     ssl = ssl_client_new(*ssl_ctx, client_fd, session_id, sizeof(session_id));
 
     /* check the return status */
     if ((ret = ssl_handshake_status(ssl)))
         goto client_test_exit;
 
     /* renegotiate client */
     if (sess_resume && sess_resume->do_reneg) 
     {
-        if (ssl_renegotiate(ssl) == -SSL_ALERT_NO_RENEGOTIATION) 
-            ret = 0;
-        else
-            ret = -SSL_ALERT_NO_RENEGOTIATION;
-
-        goto client_test_exit;
+        if ((ret = ssl_renegotiate(ssl)) < 0)
+            goto client_test_exit;
     }
 
     if (sess_resume)
     {
         memcpy(sess_resume->session_id, 
                 ssl_get_session_id(ssl), SSL_SESSION_ID_SIZE);
     }
 
     if (IS_SET_SSL_FLAG(SSL_SERVER_VERIFY_LATER) && 
                                             (ret = ssl_verify_cert(ssl)))
     {
         goto client_test_exit;
     }
 
     ssl_write(ssl, (uint8_t *)"hello world\n", 13);
     if (sess_resume)
     {
         const uint8_t *sess_id = ssl_get_session_id(ssl);
         int i;
 
         printf("    Session-ID: ");
         for (i = 0; i < SSL_SESSION_ID_SIZE; i++)
         {
             printf("%02X", sess_id[i]);
         }
         printf("\n");
         TTY_FLUSH();
     }
 
     ret = 0;
 
 client_test_exit:
     ssl_free(ssl);
     SOCKET_CLOSE(client_fd);
     usleep(200000);           /* allow openssl to say something */
 
     if (sess_resume)
     {
         if (sess_resume->stop_server)
         {
             ssl_ctx_free(*ssl_ctx);
             *ssl_ctx = NULL;
 #ifndef WIN32
             pthread_cancel(sess_resume->server_thread);
 #endif
         }
         else if (sess_resume->start_server)
         {
 #ifndef WIN32
            sess_resume->server_thread = thread;
 #endif
         }
     }
     else
     {
         ssl_ctx_free(*ssl_ctx);
         *ssl_ctx = NULL;
 #ifndef WIN32
         pthread_cancel(thread);
 #endif
     }
 
     if (ret == 0)
     {
         printf("SSL client test \"%s\" passed\n", test);
         TTY_FLUSH();
     }
 
     return ret;
 }
 
 int SSL_client_tests(void)
 {
     int ret =  -1;
     SSL_CTX *ssl_ctx = NULL;
     CLNT_SESSION_RESUME_CTX sess_resume;
     memset(&sess_resume, 0, sizeof(CLNT_SESSION_RESUME_CTX));
 
     sess_resume.start_server = 1;
     printf("### starting client tests\n");
    
     if ((ret = SSL_client_test("512 bit key", 
                     &ssl_ctx,
                     "-cert ../ssl/test/axTLS.x509_512.pem "
                     "-key ../ssl/test/axTLS.key_512.pem", &sess_resume, 
                     DEFAULT_CLNT_OPTION, NULL, NULL, NULL)))
         goto cleanup;
 
     /* all the session id's should match for session resumption */
     sess_resume.start_server = 0;
     if ((ret = SSL_client_test("Client session resumption #1", 
                     &ssl_ctx, NULL, &sess_resume, 
                     DEFAULT_CLNT_OPTION, NULL, NULL, NULL)))
         goto cleanup;
 
     // no client renegotiation
-    sess_resume.do_reneg = 1;
-    // test relies on openssl killing the call
-    if ((ret = SSL_client_test("Client renegotiation", 
-                    &ssl_ctx, NULL, &sess_resume, 
-                    DEFAULT_CLNT_OPTION, NULL, NULL, NULL)))
-        goto cleanup;
-    sess_resume.do_reneg = 0;
+    //sess_resume.do_reneg = 1;
+    //if ((ret = SSL_client_test("Client renegotiation", 
+    //                &ssl_ctx, NULL, &sess_resume, 
+    //                DEFAULT_CLNT_OPTION, NULL, NULL, NULL)) !=
+    //       -SSL_ALERT_NO_RENEGOTIATION)
+    //{
+    //    printf("*** Error: %d\n", ret); TTY_FLUSH();
+    //    goto cleanup;
+    //}
+    //sess_resume.do_reneg = 0;
 
     sess_resume.stop_server = 1;
     if ((ret = SSL_client_test("Client session resumption #2", 
                     &ssl_ctx, NULL, &sess_resume, 
                     DEFAULT_CLNT_OPTION, NULL, NULL, NULL)))
         goto cleanup;
 
     if ((ret = SSL_client_test("1024 bit key", 
                     &ssl_ctx,
                     "-cert ../ssl/test/axTLS.x509_1024.pem "
                     "-key ../ssl/test/axTLS.key_1024.pem", NULL,
                     DEFAULT_CLNT_OPTION, NULL, NULL, NULL)))
         goto cleanup;
 
     if ((ret = SSL_client_test("2048 bit key", 
                     &ssl_ctx,
                     "-cert ../ssl/test/axTLS.x509_2048.pem "
                     "-key ../ssl/test/axTLS.key_2048.pem",  NULL,
                     DEFAULT_CLNT_OPTION, NULL, NULL, NULL)))
         goto cleanup;
 
     if ((ret = SSL_client_test("4096 bit key", 
                     &ssl_ctx,
                     "-cert ../ssl/test/axTLS.x509_4096.pem "
                     "-key ../ssl/test/axTLS.key_4096.pem", NULL,
                     DEFAULT_CLNT_OPTION, NULL, NULL, NULL)))
         goto cleanup;
 
     if ((ret = SSL_client_test("Server cert chaining", 
                     &ssl_ctx,
                     "-cert ../ssl/test/axTLS.x509_device.pem "
                     "-key ../ssl/test/axTLS.device_key.pem "
                     "-CAfile ../ssl/test/axTLS.x509_512.pem ", NULL,
                     DEFAULT_CLNT_OPTION, NULL, NULL, NULL)))
         goto cleanup;
 
     /* Check the server can verify the client */
     if ((ret = SSL_client_test("Client peer authentication",
                     &ssl_ctx,
                     "-cert ../ssl/test/axTLS.x509_2048.pem "
                     "-key ../ssl/test/axTLS.key_2048.pem "
                     "-CAfile ../ssl/test/axTLS.ca_x509.pem "
                     "-verify 1 ", NULL, DEFAULT_CLNT_OPTION, 
                     "../ssl/test/axTLS.key_1024", NULL,
                     "../ssl/test/axTLS.x509_1024.cer")))
         goto cleanup;
 
     /* Should get an "ERROR" from openssl (as the handshake fails as soon as
      * the certificate verification fails) */
     if ((ret = SSL_client_test("Error: Expired cert (verify now)",
                     &ssl_ctx,
                     "-cert ../ssl/test/axTLS.x509_bad_after.pem "
                     "-key ../ssl/test/axTLS.key_512.pem", NULL,
                     DEFAULT_CLNT_OPTION, NULL, NULL, NULL)) != 
                             SSL_X509_ERROR(X509_VFY_ERROR_EXPIRED))
     {
         printf("*** Error: %d\n", ret);
         goto cleanup;
     }
 
     printf("SSL client test \"Expired cert (verify now)\" passed\n");
 
     /* There is no "ERROR" from openssl */
     if ((ret = SSL_client_test("Error: Expired cert (verify later)", 
                     &ssl_ctx,
                     "-cert ../ssl/test/axTLS.x509_bad_after.pem "
                     "-key ../ssl/test/axTLS.key_512.pem", NULL,
                     DEFAULT_CLNT_OPTION|SSL_SERVER_VERIFY_LATER, NULL, 
                     NULL, NULL)) != SSL_X509_ERROR(X509_VFY_ERROR_EXPIRED))
     {
         printf("*** Error: %d\n", ret); TTY_FLUSH();
         goto cleanup;
     }
 
     printf("SSL client test \"Expired cert (verify later)\" passed\n");
     ret = 0;
 
 cleanup:
     if (ret)
     {
         ssl_display_error(ret);
         printf("Error: A client test failed\n");
         exit(1);
     }
     else
     {
         printf("All client tests passed\n"); TTY_FLUSH();
     }
 
     ssl_ctx_free(ssl_ctx);
     return ret;
 }
 
 /**************************************************************************
  * SSL Basic Testing (test a big packet handshake)
  *
  **************************************************************************/
 static uint8_t basic_buf[256*1024];
 
 static void do_basic(void)
 {
     int client_fd;
     SSL *ssl_clnt;
     SSL_CTX *ssl_clnt_ctx = ssl_ctx_new(
                             DEFAULT_CLNT_OPTION, SSL_DEFAULT_CLNT_SESS);
     usleep(200000);           /* allow server to start */
 
     if ((client_fd = client_socket_init(g_port)) < 0)
         goto error;
 
     if (ssl_obj_load(ssl_clnt_ctx, SSL_OBJ_X509_CACERT, 
                                         "../ssl/test/axTLS.ca_x509.cer", NULL))
         goto error;
 
     ssl_clnt = ssl_client_new(ssl_clnt_ctx, client_fd, NULL, 0);
 
     /* check the return status */
     if (ssl_handshake_status(ssl_clnt) < 0)
     {
+        printf("YA YA\n");
         ssl_display_error(ssl_handshake_status(ssl_clnt));
         goto error;
     }
 
     ssl_write(ssl_clnt, basic_buf, sizeof(basic_buf));
     ssl_free(ssl_clnt);
 
 error:
     ssl_ctx_free(ssl_clnt_ctx);
     SOCKET_CLOSE(client_fd);
 
     /* exit this thread */
 }
 
 static int SSL_basic_test(void)
 {
     int server_fd, client_fd, ret = 0, size = 0, offset = 0;
     SSL_CTX *ssl_svr_ctx = NULL;
     struct sockaddr_in client_addr;
     uint8_t *read_buf;
     socklen_t clnt_len = sizeof(client_addr);
     SSL *ssl_svr;
 #ifndef WIN32
     pthread_t thread;
 #endif
     memset(basic_buf, 0xA5, sizeof(basic_buf)/2);
     memset(&basic_buf[sizeof(basic_buf)/2], 0x5A, sizeof(basic_buf)/2);
 
     if ((server_fd = server_socket_init(&g_port)) < 0)
         goto error;
 
     ssl_svr_ctx = ssl_ctx_new(DEFAULT_SVR_OPTION, SSL_DEFAULT_SVR_SESS);
 
 #ifndef WIN32
     pthread_create(&thread, NULL, 
                 (void *(*)(void *))do_basic, NULL);
     pthread_detach(thread);
 #else
     CreateThread(NULL, 1024, (LPTHREAD_START_ROUTINE)do_basic, NULL, 0, NULL);
 #endif
 
     /* Wait for a client to connect */
     if ((client_fd = accept(server_fd, 
                     (struct sockaddr *) &client_addr, &clnt_len)) < 0)
     {
         ret = SSL_ERROR_SOCK_SETUP_FAILURE;
         goto error;
     }
     
     /* we are ready to go */
     ssl_svr = ssl_server_new(ssl_svr_ctx, client_fd);
     
     do
     {
         while ((size = ssl_read(ssl_svr, &read_buf)) == SSL_OK);
 
         if (size < SSL_OK) /* got some alert or something nasty */
         {
             printf("Server ");
             ssl_display_error(size);
             ret = size;
             break;
         }
         else /* looks more promising */
         {
             if (memcmp(read_buf, &basic_buf[offset], size) != 0)
             {
                 ret = SSL_NOT_OK;
                 break;
             }
         }
 
         offset += size;
     } while (offset < sizeof(basic_buf));
 
     printf(ret == SSL_OK && offset == sizeof(basic_buf) ? 
                             "SSL basic test passed\n" :
                             "SSL basic test failed\n");
     TTY_FLUSH();
 
     ssl_free(ssl_svr);
     SOCKET_CLOSE(server_fd);
     SOCKET_CLOSE(client_fd);
 
 error:
     ssl_ctx_free(ssl_svr_ctx);
     return ret;
 }
 
 #if !defined(WIN32) && defined(CONFIG_SSL_CTX_MUTEXING)
 /**************************************************************************
  * Multi-Threading Tests
  *
  **************************************************************************/
 #define NUM_THREADS         100
 
 typedef struct
 {
     SSL_CTX *ssl_clnt_ctx;
     int port;
     int thread_id;
 } multi_t;
 
 void do_multi_clnt(multi_t *multi_data)
 {
     int res = 1, client_fd, i;
     SSL *ssl = NULL;
     char tmp[5];
 
     if ((client_fd = client_socket_init(multi_data->port)) < 0)
         goto client_test_exit;
 
     sleep(1);
     ssl = ssl_client_new(multi_data->ssl_clnt_ctx, client_fd, NULL, 0);
 
     if ((res = ssl_handshake_status(ssl)))
     {
         printf("Client ");
         ssl_display_error(res);
         goto client_test_exit;
     }
 
     sprintf(tmp, "%d\n", multi_data->thread_id);
     for (i = 0; i < 10; i++)
         ssl_write(ssl, (uint8_t *)tmp, strlen(tmp)+1);
 
 client_test_exit:
     ssl_free(ssl);
     SOCKET_CLOSE(client_fd);
     free(multi_data);
 }
 
 void do_multi_svr(SSL *ssl)
 {
     uint8_t *read_buf;
     int *res_ptr = malloc(sizeof(int));
     int res;
 
     for (;;)
     {
         res = ssl_read(ssl, &read_buf);
 
         /* kill the client */
         if (res != SSL_OK)
         {
             if (res == SSL_ERROR_CONN_LOST)
             {
                 SOCKET_CLOSE(ssl->client_fd);
                 ssl_free(ssl);
                 break;
             }
             else if (res > 0)
             {
                 /* do nothing */
             }
             else /* some problem */
             {
                 printf("Server ");
                 ssl_display_error(res);
                 goto error;
             }
         }
     }
 
     res = SSL_OK;
 error:
     *res_ptr = res;
     pthread_exit(res_ptr);
 }
 
 int multi_thread_test(void)
 {
     int server_fd = -1;
     SSL_CTX *ssl_server_ctx;
     SSL_CTX *ssl_clnt_ctx;
     pthread_t clnt_threads[NUM_THREADS];
     pthread_t svr_threads[NUM_THREADS];
     int i, res = 0;
     struct sockaddr_in client_addr;
     socklen_t clnt_len = sizeof(client_addr);
 
     printf("Do multi-threading test (takes a minute)\n");
 
     ssl_server_ctx = ssl_ctx_new(DEFAULT_SVR_OPTION, SSL_DEFAULT_SVR_SESS);
     ssl_clnt_ctx = ssl_ctx_new(DEFAULT_CLNT_OPTION, SSL_DEFAULT_CLNT_SESS);
 
     if (ssl_obj_load(ssl_clnt_ctx, SSL_OBJ_X509_CACERT, 
                                         "../ssl/test/axTLS.ca_x509.cer", NULL))
         goto error;
 
     if ((server_fd = server_socket_init(&g_port)) < 0)
         goto error;
 
     for (i = 0; i < NUM_THREADS; i++)
     {
         multi_t *multi_data = (multi_t *)malloc(sizeof(multi_t));
         multi_data->ssl_clnt_ctx = ssl_clnt_ctx;
         multi_data->port = g_port;
         multi_data->thread_id = i+1;
         pthread_create(&clnt_threads[i], NULL, 
                 (void *(*)(void *))do_multi_clnt, (void *)multi_data);
         pthread_detach(clnt_threads[i]);
     }
 
     for (i = 0; i < NUM_THREADS; i++)
     { 
         SSL *ssl_svr;
         int client_fd = accept(server_fd, 
                       (struct sockaddr *)&client_addr, &clnt_len);
 
         if (client_fd < 0)
             goto error;
 
         ssl_svr = ssl_server_new(ssl_server_ctx, client_fd);
 
         pthread_create(&svr_threads[i], NULL, 
                         (void *(*)(void *))do_multi_svr, (void *)ssl_svr);
     }
 
     /* make sure we've run all of the threads */
     for (i = 0; i < NUM_THREADS; i++)
     {
         void *thread_res;
         pthread_join(svr_threads[i], &thread_res);
 
         if (*((int *)thread_res) != 0)
             res = 1;
 
         free(thread_res);
     } 
 
     if (res) 
         goto error;
 
     printf("Multi-thread test passed (%d)\n", NUM_THREADS);
 error:
     ssl_ctx_free(ssl_server_ctx);
     ssl_ctx_free(ssl_clnt_ctx);
     SOCKET_CLOSE(server_fd);
     return res;
 }
 #endif /* !defined(WIN32) && defined(CONFIG_SSL_CTX_MUTEXING) */ 
 
 /**************************************************************************
  * Header issue
  *
  **************************************************************************/
 static void do_header_issue(void)
 {
     char axtls_buf[2048];
 #ifndef WIN32
     pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
 #endif
     sprintf(axtls_buf, "./axssl s_client -connect localhost:%d", g_port);
     system(axtls_buf);
 }
 
 static int header_issue(void)
 {
     FILE *f = fopen("../ssl/test/header_issue.dat", "r");
     int server_fd = -1, client_fd = -1, ret = 1;
     uint8_t buf[2048];
     int size = 0;
     struct sockaddr_in client_addr;
     socklen_t clnt_len = sizeof(client_addr);
 #ifndef WIN32
     pthread_t thread;
 #endif
 
     if (f == NULL || (server_fd = server_socket_init(&g_port)) < 0)
         goto error;
 
 #ifndef WIN32
     pthread_create(&thread, NULL, 
                 (void *(*)(void *))do_header_issue, NULL);
     pthread_detach(thread);
 #else
     CreateThread(NULL, 1024, (LPTHREAD_START_ROUTINE)do_header_issue, 
                 NULL, 0, NULL);
 #endif
     if ((client_fd = accept(server_fd, 
                     (struct sockaddr *) &client_addr, &clnt_len)) < 0)
     {
         ret = SSL_ERROR_SOCK_SETUP_FAILURE;
         goto error;
     }
 
     size = fread(buf, 1, sizeof(buf), f);
     SOCKET_WRITE(client_fd, buf, size);
     usleep(200000);
 
     ret = 0;
 error:
     fclose(f);
     SOCKET_CLOSE(client_fd);
     SOCKET_CLOSE(server_fd);
     TTY_FLUSH();
     system("killall axssl");
     return ret;
 }
 
 /**************************************************************************
  * main()
  *
  **************************************************************************/
 int main(int argc, char *argv[])
 {
     int ret = 1;
     BI_CTX *bi_ctx;
     int fd;
 
 #ifdef WIN32
     WSADATA wsaData;
     WORD wVersionRequested = MAKEWORD(2, 2);
     WSAStartup(wVersionRequested, &wsaData);
     fd = _open("test_result.txt", O_WRONLY|O_TEMPORARY|O_CREAT, _S_IWRITE);
     dup2(fd, 2);                        /* write stderr to this file */
 #else
     fd = open("/dev/null", O_WRONLY);   /* write stderr to /dev/null */
     signal(SIGPIPE, SIG_IGN);           /* ignore pipe errors */
     dup2(fd, 2);
 #endif
 
     /* can't do testing in this mode */
 #if defined CONFIG_SSL_GENERATE_X509_CERT
     printf("Error: Must compile with default key/certificates\n");
     exit(1);
 #endif
 
     bi_ctx = bi_initialize();
 
     if (AES_test(bi_ctx))
     {
         printf("AES tests failed\n");
         goto cleanup;
     }
     TTY_FLUSH();
 
     if (RC4_test(bi_ctx))
     {
         printf("RC4 tests failed\n");
         goto cleanup;
     }
     TTY_FLUSH();
 
     if (MD5_test(bi_ctx))
     {
         printf("MD5 tests failed\n");
         goto cleanup;
     }
     TTY_FLUSH();
 
     if (SHA1_test(bi_ctx))
     {
         printf("SHA1 tests failed\n");
         goto cleanup;
     }
     TTY_FLUSH();
 
     if (HMAC_test(bi_ctx))
     {
         printf("HMAC tests failed\n");
         goto cleanup;
     }
     TTY_FLUSH();
 
     if (BIGINT_test(bi_ctx))
     {
         printf("BigInt tests failed!\n");
         goto cleanup;
     }
     TTY_FLUSH();
 
     bi_terminate(bi_ctx);
 
     if (RSA_test())
     {
         printf("RSA tests failed\n");
         goto cleanup;
     }
     TTY_FLUSH();
 
     if (cert_tests())
     {
         printf("CERT tests failed\n");
         goto cleanup;
     }
     TTY_FLUSH();
 
 #if !defined(WIN32) && defined(CONFIG_SSL_CTX_MUTEXING)
     if (multi_thread_test())
         goto cleanup;
 #endif
 
     if (SSL_basic_test())
         goto cleanup;
 
     system("sh ../ssl/test/killopenssl.sh");
 
     if (SSL_client_tests())
         goto cleanup;
 
     system("sh ../ssl/test/killopenssl.sh");
 
     if (SSL_server_tests())
         goto cleanup;
 
     system("sh ../ssl/test/killopenssl.sh");
 
     if (header_issue())
     {
         printf("Header tests failed\n"); TTY_FLUSH();
         goto cleanup;
     }
 
     ret = 0;        /* all ok */
     printf("**** ALL TESTS PASSED ****\n"); TTY_FLUSH();
 cleanup:
 
     if (ret)
         printf("Error: Some tests failed!\n");
 
     close(fd);
     return ret;
 }
Index: ssl/tls1.c
===================================================================
--- ssl/tls1.c	(revision 176)
+++ ssl/tls1.c	(revision 175)
@@ -1,2115 +1,2115 @@
 /*
  * Copyright (c) 2007, Cameron Rich
  * 
  * All rights reserved.
  * 
  * Redistribution and use in source and binary forms, with or without 
  * modification, are permitted provided that the following conditions are met:
  *
  * * Redistributions of source code must retain the above copyright notice, 
  *   this list of conditions and the following disclaimer.
  * * Redistributions in binary form must reproduce the above copyright notice, 
  *   this list of conditions and the following disclaimer in the documentation 
  *   and/or other materials provided with the distribution.
  * * Neither the name of the axTLS project nor the names of its contributors 
  *   may be used to endorse or promote products derived from this software 
  *   without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 /**
  * Common ssl/tlsv1 code to both the client and server implementations.
  */
 
 #include <string.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <stdarg.h>
 #include "ssl.h"
 
 /* The session expiry time */
 #define SSL_EXPIRY_TIME     (CONFIG_SSL_EXPIRY_TIME*3600)
 
 static const uint8_t g_hello_request[] = { HS_HELLO_REQUEST, 0, 0, 0 };
 static const uint8_t g_chg_cipher_spec_pkt[] = { 1 };
 static const char * server_finished = "server finished";
 static const char * client_finished = "client finished";
 
 static int do_handshake(SSL *ssl, uint8_t *buf, int read_len);
 static int set_key_block(SSL *ssl, int is_write);
 static int verify_digest(SSL *ssl, int mode, const uint8_t *buf, int read_len);
 static void *crypt_new(SSL *ssl, uint8_t *key, uint8_t *iv, int is_decrypt);
 static int send_raw_packet(SSL *ssl, uint8_t protocol);
 
 /**
  * The server will pick the cipher based on the order that the order that the
  * ciphers are listed. This order is defined at compile time.
  */
 #ifdef CONFIG_SSL_SKELETON_MODE
 const uint8_t ssl_prot_prefs[NUM_PROTOCOLS] = 
 { SSL_RC4_128_SHA };
 #else
 static void session_free(SSL_SESSION *ssl_sessions[], int sess_index);
 
 const uint8_t ssl_prot_prefs[NUM_PROTOCOLS] = 
 #ifdef CONFIG_SSL_PROT_LOW                  /* low security, fast speed */
 { SSL_RC4_128_SHA, SSL_AES128_SHA, SSL_AES256_SHA, SSL_RC4_128_MD5 };
 #elif CONFIG_SSL_PROT_MEDIUM                /* medium security, medium speed */
 { SSL_AES128_SHA, SSL_AES256_SHA, SSL_RC4_128_SHA, SSL_RC4_128_MD5 };    
 #else /* CONFIG_SSL_PROT_HIGH */            /* high security, low speed */
 { SSL_AES256_SHA, SSL_AES128_SHA, SSL_RC4_128_SHA, SSL_RC4_128_MD5 };
 #endif
 #endif /* CONFIG_SSL_SKELETON_MODE */
 
 /**
  * The cipher map containing all the essentials for each cipher.
  */
 #ifdef CONFIG_SSL_SKELETON_MODE
 static const cipher_info_t cipher_info[NUM_PROTOCOLS] = 
 {
     {   /* RC4-SHA */
         SSL_RC4_128_SHA,                /* RC4-SHA */
         16,                             /* key size */
         0,                              /* iv size */ 
         2*(SHA1_SIZE+16),               /* key block size */
         0,                              /* no padding */
         SHA1_SIZE,                      /* digest size */
         hmac_sha1,                      /* hmac algorithm */
         (crypt_func)RC4_crypt,          /* encrypt */
         (crypt_func)RC4_crypt           /* decrypt */
     },
 };
 #else
 static const cipher_info_t cipher_info[NUM_PROTOCOLS] = 
 {
     {   /* AES128-SHA */
         SSL_AES128_SHA,                 /* AES128-SHA */
         16,                             /* key size */
         16,                             /* iv size */ 
         2*(SHA1_SIZE+16+16),            /* key block size */
         16,                             /* block padding size */
         SHA1_SIZE,                      /* digest size */
         hmac_sha1,                      /* hmac algorithm */
         (crypt_func)AES_cbc_encrypt,    /* encrypt */
         (crypt_func)AES_cbc_decrypt     /* decrypt */
     },
     {   /* AES256-SHA */
         SSL_AES256_SHA,                 /* AES256-SHA */
         32,                             /* key size */
         16,                             /* iv size */ 
         2*(SHA1_SIZE+32+16),            /* key block size */
         16,                             /* block padding size */
         SHA1_SIZE,                      /* digest size */
         hmac_sha1,                      /* hmac algorithm */
         (crypt_func)AES_cbc_encrypt,    /* encrypt */
         (crypt_func)AES_cbc_decrypt     /* decrypt */
     },       
     {   /* RC4-SHA */
         SSL_RC4_128_SHA,                /* RC4-SHA */
         16,                             /* key size */
         0,                              /* iv size */ 
         2*(SHA1_SIZE+16),               /* key block size */
         0,                              /* no padding */
         SHA1_SIZE,                      /* digest size */
         hmac_sha1,                      /* hmac algorithm */
         (crypt_func)RC4_crypt,          /* encrypt */
         (crypt_func)RC4_crypt           /* decrypt */
     },
     /*
      * This protocol is from SSLv2 days and is unlikely to be used - but was
      * useful for testing different possible digest algorithms.
      */
     {   /* RC4-MD5 */
         SSL_RC4_128_MD5,                /* RC4-MD5 */
         16,                             /* key size */
         0,                              /* iv size */ 
         2*(MD5_SIZE+16),                /* key block size */
         0,                              /* no padding */
         MD5_SIZE,                       /* digest size */
         hmac_md5,                       /* hmac algorithm */
         (crypt_func)RC4_crypt,          /* encrypt */
         (crypt_func)RC4_crypt           /* decrypt */
     },
 };
 #endif
 
 static void prf(const uint8_t *sec, int sec_len, uint8_t *seed, int seed_len,
         uint8_t *out, int olen);
 static const cipher_info_t *get_cipher_info(uint8_t cipher);
 static void increment_read_sequence(SSL *ssl);
 static void increment_write_sequence(SSL *ssl);
 static void add_hmac_digest(SSL *ssl, int snd, uint8_t *hmac_header,
         const uint8_t *buf, int buf_len, uint8_t *hmac_buf);
 
 /* win32 VC6.0 doesn't have variadic macros */
 #if defined(WIN32) && !defined(CONFIG_SSL_FULL_MODE)
 void DISPLAY_BYTES(SSL *ssl, const char *format, 
         const uint8_t *data, int size, ...) {}
 #endif
 
 /**
  * Establish a new client/server context.
  */
 EXP_FUNC SSL_CTX *STDCALL ssl_ctx_new(uint32_t options, int num_sessions)
 {
     SSL_CTX *ssl_ctx = (SSL_CTX *)calloc(1, sizeof (SSL_CTX));
     ssl_ctx->options = options;
 
     if (load_key_certs(ssl_ctx) < 0)
     {
         free(ssl_ctx);  /* can't load our key/certificate pair, so die */
         return NULL;
     }
 
 #ifndef CONFIG_SSL_SKELETON_MODE
     ssl_ctx->num_sessions = num_sessions;
 #endif
 
     SSL_CTX_MUTEX_INIT(ssl_ctx->mutex);
 
 #ifndef CONFIG_SSL_SKELETON_MODE
     if (num_sessions)
     {
         ssl_ctx->ssl_sessions = (SSL_SESSION **)
                         calloc(1, num_sessions*sizeof(SSL_SESSION *));
     }
 #endif
 
     return ssl_ctx;
 }
 
 /*
  * Remove a client/server context.
  */
 EXP_FUNC void STDCALL ssl_ctx_free(SSL_CTX *ssl_ctx)
 {
     SSL *ssl;
     int i;
 
     if (ssl_ctx == NULL)
         return;
 
     ssl = ssl_ctx->head;
 
     /* clear out all the ssl entries */
     while (ssl)
     {
         SSL *next = ssl->next;
         ssl_free(ssl);
         ssl = next;
     }
 
 #ifndef CONFIG_SSL_SKELETON_MODE
     /* clear out all the sessions */
     for (i = 0; i < ssl_ctx->num_sessions; i++)
         session_free(ssl_ctx->ssl_sessions, i);
 
     free(ssl_ctx->ssl_sessions);
 #endif
 
     i = 0;
     while (i < CONFIG_SSL_MAX_CERTS && ssl_ctx->certs[i].buf)
     {
         free(ssl_ctx->certs[i].buf);
         ssl_ctx->certs[i++].buf = NULL;
     }
 
 #ifdef CONFIG_SSL_CERT_VERIFICATION
     remove_ca_certs(ssl_ctx->ca_cert_ctx);
 #endif
     ssl_ctx->chain_length = 0;
     SSL_CTX_MUTEX_DESTROY(ssl_ctx->mutex);
     RSA_free(ssl_ctx->rsa_ctx);
     RNG_terminate();
     free(ssl_ctx);
 }
 
 /*
  * Free any used resources used by this connection.
  */
 EXP_FUNC void STDCALL ssl_free(SSL *ssl)
 {
     SSL_CTX *ssl_ctx;
 
     if (ssl == NULL)        /* just ignore null pointers */
         return;
 
     /* spec says we must notify when we are dying */
     send_alert(ssl, SSL_ALERT_CLOSE_NOTIFY);
 
     ssl_ctx = ssl->ssl_ctx;
 
     SSL_CTX_LOCK(ssl_ctx->mutex);
 
     /* adjust the server SSL list */
     if (ssl->prev)
         ssl->prev->next = ssl->next;
     else
         ssl_ctx->head = ssl->next;
 
     if (ssl->next)
         ssl->next->prev = ssl->prev;
     else
         ssl_ctx->tail = ssl->prev;
 
     SSL_CTX_UNLOCK(ssl_ctx->mutex);
 
     /* may already be free - but be sure */
     free(ssl->encrypt_ctx);
     free(ssl->decrypt_ctx);
     disposable_free(ssl);
 #ifdef CONFIG_SSL_CERT_VERIFICATION
     x509_free(ssl->x509_ctx);
 #endif
 
     free(ssl);
 }
 
 /*
  * Read the SSL connection and send any alerts for various errors.
  */
 EXP_FUNC int STDCALL ssl_read(SSL *ssl, uint8_t **in_data)
 {
     int ret = basic_read(ssl, in_data);
 
     /* check for return code so we can send an alert */
     if (ret < SSL_OK)
     {
         if (ret != SSL_ERROR_CONN_LOST)
         {
             send_alert(ssl, ret);
 #ifndef CONFIG_SSL_SKELETON_MODE
             /* something nasty happened, so get rid of this session */
             kill_ssl_session(ssl->ssl_ctx->ssl_sessions, ssl);
 #endif
         }
     }
 
     return ret;
 }
 
 /*
  * Write application data to the client
  */
 EXP_FUNC int STDCALL ssl_write(SSL *ssl, const uint8_t *out_data, int out_len)
 {
     int n = out_len, nw, i, tot = 0;
 
     /* maximum size of a TLS packet is around 16kB, so fragment */
     do 
     {
         nw = n;
 
         if (nw > RT_MAX_PLAIN_LENGTH)    /* fragment if necessary */
             nw = RT_MAX_PLAIN_LENGTH;
 
         if ((i = send_packet(ssl, PT_APP_PROTOCOL_DATA, 
                                             &out_data[tot], nw)) <= 0)
         {
             out_len = i;    /* an error */
             break;
         }
 
         tot += i;
         n -= i;
     } while (n > 0);
 
     return out_len;
 }
 
 /**
  * Add a certificate to the certificate chain.
  */
 int add_cert(SSL_CTX *ssl_ctx, const uint8_t *buf, int len)
 {
     int ret = SSL_ERROR_NO_CERT_DEFINED, i = 0;
     SSL_CERT *ssl_cert;
     X509_CTX *cert = NULL;
     int offset;
 
     while (ssl_ctx->certs[i].buf && i < CONFIG_SSL_MAX_CERTS) 
         i++;
 
     if (i == CONFIG_SSL_MAX_CERTS) /* too many certs */
     {
 #ifdef CONFIG_SSL_FULL_MODE
         printf("Error: maximum number of certs added - change of "
                 "compile-time configuration required\n");
 #endif
         goto error;
     }
 
     if ((ret = x509_new(buf, &offset, &cert)))
         goto error;
 
 #if defined (CONFIG_SSL_FULL_MODE)
     if (ssl_ctx->options & SSL_DISPLAY_CERTS)
         x509_print(cert, NULL);
 #endif
 
     ssl_cert = &ssl_ctx->certs[i];
     ssl_cert->size = len;
     ssl_cert->buf = (uint8_t *)malloc(len);
     memcpy(ssl_cert->buf, buf, len);
     ssl_ctx->chain_length++;
     len -= offset;
     ret = SSL_OK;           /* ok so far */
 
     /* recurse? */
     if (len > 0)
     {
         ret = add_cert(ssl_ctx, &buf[offset], len);
     }
 
 error:
     x509_free(cert);        /* don't need anymore */
     return ret;
 }
 
 #ifdef CONFIG_SSL_CERT_VERIFICATION
 /**
  * Add a certificate authority.
  */
 int add_cert_auth(SSL_CTX *ssl_ctx, const uint8_t *buf, int len)
 {
     int ret = SSL_ERROR_NO_CERT_DEFINED;
     int i = 0;
     int offset;
     CA_CERT_CTX *ca_cert_ctx;
 
     if (ssl_ctx->ca_cert_ctx == NULL)
         ssl_ctx->ca_cert_ctx = (CA_CERT_CTX *)calloc(1, sizeof(CA_CERT_CTX));
 
     ca_cert_ctx = ssl_ctx->ca_cert_ctx;
 
     while (i < CONFIG_X509_MAX_CA_CERTS && ca_cert_ctx->cert[i]) 
         i++;
 
     if (i > CONFIG_X509_MAX_CA_CERTS)
     {
 #ifdef CONFIG_SSL_FULL_MODE
         printf("Error: maximum number of CA certs added - change of "
                 "compile-time configuration required\n");
 #endif
         goto error;
     }
 
     if ((ret = x509_new(buf, &offset, &ca_cert_ctx->cert[i])))
         goto error;
 
     len -= offset;
     ret = SSL_OK;           /* ok so far */
 
     /* recurse? */
     if (len > 0)
         ret = add_cert_auth(ssl_ctx, &buf[offset], len);
 
 error:
     return ret;
 }
 
 
 /*
  * Retrieve an X.509 distinguished name component
  */
 EXP_FUNC const char * STDCALL ssl_get_cert_dn(const SSL *ssl, int component)
 {
     if (ssl->x509_ctx == NULL)
         return NULL;
 
     switch (component)
     {
         case SSL_X509_CERT_COMMON_NAME:
             return ssl->x509_ctx->cert_dn[X509_COMMON_NAME];
 
         case SSL_X509_CERT_ORGANIZATION:
             return ssl->x509_ctx->cert_dn[X509_ORGANIZATION];
 
         case SSL_X509_CERT_ORGANIZATIONAL_NAME:       
             return ssl->x509_ctx->cert_dn[X509_ORGANIZATIONAL_UNIT];
 
         case SSL_X509_CA_CERT_COMMON_NAME:
             return ssl->x509_ctx->ca_cert_dn[X509_COMMON_NAME];
 
         case SSL_X509_CA_CERT_ORGANIZATION:
             return ssl->x509_ctx->ca_cert_dn[X509_ORGANIZATION];
 
         case SSL_X509_CA_CERT_ORGANIZATIONAL_NAME:       
             return ssl->x509_ctx->ca_cert_dn[X509_ORGANIZATIONAL_UNIT];
 
         default:
             return NULL;
     }
 }
 
 /*
  * Retrieve a "Subject Alternative Name" from a v3 certificate
  */
 EXP_FUNC const char * STDCALL ssl_get_cert_subject_alt_dnsname(const SSL *ssl,
         int dnsindex)
 {
     int i;
 
     if (ssl->x509_ctx == NULL || ssl->x509_ctx->subject_alt_dnsnames == NULL)
         return NULL;
 
     for (i = 0; i < dnsindex; ++i)
     {
         if (ssl->x509_ctx->subject_alt_dnsnames[i] == NULL)
             return NULL;
     }
 
     return ssl->x509_ctx->subject_alt_dnsnames[dnsindex];
 }
 
 #endif /* CONFIG_SSL_CERT_VERIFICATION */
 
 /*
  * Find an ssl object based on the client's file descriptor.
  */
 EXP_FUNC SSL * STDCALL ssl_find(SSL_CTX *ssl_ctx, int client_fd)
 {
     SSL *ssl;
 
     SSL_CTX_LOCK(ssl_ctx->mutex);
     ssl = ssl_ctx->head;
 
     /* search through all the ssl entries */
     while (ssl)
     {
         if (ssl->client_fd == client_fd)
         {
             SSL_CTX_UNLOCK(ssl_ctx->mutex);
             return ssl;
         }
 
         ssl = ssl->next;
     }
 
     SSL_CTX_UNLOCK(ssl_ctx->mutex);
     return NULL;
 }
 
 /*
  * Force the client to perform its handshake again.
  */
 EXP_FUNC int STDCALL ssl_renegotiate(SSL *ssl)
 {
     int ret = SSL_OK;
 
     disposable_new(ssl);
 #ifdef CONFIG_SSL_ENABLE_CLIENT
     if (IS_SET_SSL_FLAG(SSL_IS_CLIENT))
     {
         ret = do_client_connect(ssl);
     }
     else
 #endif
     {
         send_packet(ssl, PT_HANDSHAKE_PROTOCOL, 
                 g_hello_request, sizeof(g_hello_request));
         SET_SSL_FLAG(SSL_NEED_RECORD);
     }
 
     return ret;
 }
 
 /**
  * @brief Get what we need for key info.
  * @param cipher    [in]    The cipher information we are after
  * @param key_size  [out]   The key size for the cipher
  * @param iv_size   [out]   The iv size for the cipher
  * @return  The amount of key information we need.
  */
 static const cipher_info_t *get_cipher_info(uint8_t cipher)
 {
     int i;
 
     for (i = 0; i < NUM_PROTOCOLS; i++)
     {
         if (cipher_info[i].cipher == cipher)
         {
             return &cipher_info[i];
         }
     }
 
     return NULL;  /* error */
 }
 
 /*
  * Get a new ssl context for a new connection.
  */
 SSL *ssl_new(SSL_CTX *ssl_ctx, int client_fd)
 {
     SSL *ssl = (SSL *)calloc(1, sizeof(SSL));
     ssl->ssl_ctx = ssl_ctx;
     ssl->need_bytes = SSL_RECORD_SIZE;      /* need a record */
     ssl->client_fd = client_fd;
     ssl->flag = SSL_NEED_RECORD;
     ssl->bm_data = ssl->bm_all_data+BM_RECORD_OFFSET; /* space at the start */
     ssl->hs_status = SSL_NOT_OK;            /* not connected */
 #ifdef CONFIG_ENABLE_VERIFICATION
     ssl->ca_cert_ctx = ssl_ctx->ca_cert_ctx;
 #endif
     disposable_new(ssl);
 
     /* a bit hacky but saves a few bytes of memory */
     ssl->flag |= ssl_ctx->options;
     SSL_CTX_LOCK(ssl_ctx->mutex);
 
     if (ssl_ctx->head == NULL)
     {
         ssl_ctx->head = ssl;
         ssl_ctx->tail = ssl;
     }
     else
     {
         ssl->prev = ssl_ctx->tail;
         ssl_ctx->tail->next = ssl;
         ssl_ctx->tail = ssl;
     }
 
     SSL_CTX_UNLOCK(ssl_ctx->mutex);
     return ssl;
 }
 
 /*
  * Add a private key to a context.
  */
 int add_private_key(SSL_CTX *ssl_ctx, SSLObjLoader *ssl_obj)
 {
     int ret = SSL_OK;
 
     /* get the private key details */
     if (asn1_get_private_key(ssl_obj->buf, ssl_obj->len, &ssl_ctx->rsa_ctx))
     {
         ret = SSL_ERROR_INVALID_KEY;
         goto error;
     }
 
 error:
     return ret;
 }
 
 /** 
  * Increment the read sequence number (as a 64 bit endian indepenent #)
  */     
 static void increment_read_sequence(SSL *ssl)
 {
     int i;
 
     for (i = 7; i >= 0; i--) 
     {       
         if (++ssl->read_sequence[i])
             break;
     }
 }
             
 /**
  * Increment the read sequence number (as a 64 bit endian indepenent #)
  */      
 static void increment_write_sequence(SSL *ssl)
 {        
     int i;                  
          
     for (i = 7; i >= 0; i--)
     {                       
         if (++ssl->write_sequence[i])
             break;
     }                       
 }
 
 /**
  * Work out the HMAC digest in a packet.
  */
 static void add_hmac_digest(SSL *ssl, int mode, uint8_t *hmac_header,
         const uint8_t *buf, int buf_len, uint8_t *hmac_buf)
 {
     int hmac_len = buf_len + 8 + SSL_RECORD_SIZE;
     uint8_t *t_buf = (uint8_t *)alloca(hmac_len+10);
 
     memcpy(t_buf, (mode == SSL_SERVER_WRITE || mode == SSL_CLIENT_WRITE) ? 
                     ssl->write_sequence : ssl->read_sequence, 8);
     memcpy(&t_buf[8], hmac_header, SSL_RECORD_SIZE);
     memcpy(&t_buf[8+SSL_RECORD_SIZE], buf, buf_len);
 
     ssl->cipher_info->hmac(t_buf, hmac_len, 
             (mode == SSL_SERVER_WRITE || mode == SSL_CLIENT_READ) ? 
                 ssl->server_mac : ssl->client_mac, 
             ssl->cipher_info->digest_size, hmac_buf);
 
 #if 0
     print_blob("record", ssl->hmac_tx, SSL_RECORD_SIZE);
     print_blob("buf", buf, buf_len);
     if (mode == SSL_SERVER_WRITE || mode == SSL_CLIENT_WRITE)
     {
         print_blob("write seq", ssl->write_sequence, 8);
     }
     else
     {
         print_blob("read seq", ssl->read_sequence, 8);
     }
 
     if (mode == SSL_SERVER_WRITE || mode == SSL_CLIENT_READ)
     {
         print_blob("server mac", 
                 ssl->server_mac, ssl->cipher_info->digest_size);
     }
     else
     {
         print_blob("client mac", 
                 ssl->client_mac, ssl->cipher_info->digest_size);
     }
     print_blob("hmac", hmac_buf, SHA1_SIZE);
 #endif
 }
 
 /**
  * Verify that the digest of a packet is correct.
  */
 static int verify_digest(SSL *ssl, int mode, const uint8_t *buf, int read_len)
 {   
     uint8_t hmac_buf[SHA1_SIZE];
     int hmac_offset;
    
     if (ssl->cipher_info->padding_size)
     {
         hmac_offset = read_len-buf[read_len-1]-ssl->cipher_info->digest_size-1;
     }
     else
     {
         hmac_offset = read_len - ssl->cipher_info->digest_size;
     }
 
     /* sanity check the offset */
     if (hmac_offset < 0)
     {
         return SSL_ERROR_INVALID_HMAC;
     }
 
     ssl->hmac_header[3] = hmac_offset >> 8;      /* insert size */
     ssl->hmac_header[4] = hmac_offset & 0xff;
     add_hmac_digest(ssl, mode, ssl->hmac_header, buf, hmac_offset, hmac_buf);
 
     if (memcmp(hmac_buf, &buf[hmac_offset], ssl->cipher_info->digest_size))
     {
         return SSL_ERROR_INVALID_HMAC;
     }
 
     return hmac_offset;
 }
 
 /**
  * Add a packet to the end of our sent and received packets, so that we may use
  * it to calculate the hash at the end.
  */
 void add_packet(SSL *ssl, const uint8_t *pkt, int len)
 {
     MD5_Update(&ssl->dc->md5_ctx, pkt, len);
     SHA1_Update(&ssl->dc->sha1_ctx, pkt, len);
 }
 
 /**
  * Work out the MD5 PRF.
  */
 static void p_hash_md5(const uint8_t *sec, int sec_len, 
         uint8_t *seed, int seed_len, uint8_t *out, int olen)
 {
     uint8_t a1[128];
 
     /* A(1) */
     hmac_md5(seed, seed_len, sec, sec_len, a1);
     memcpy(&a1[MD5_SIZE], seed, seed_len);
     hmac_md5(a1, MD5_SIZE+seed_len, sec, sec_len, out);
 
     while (olen > MD5_SIZE)
     {
         uint8_t a2[MD5_SIZE];
         out += MD5_SIZE;
         olen -= MD5_SIZE;
 
         /* A(N) */
         hmac_md5(a1, MD5_SIZE, sec, sec_len, a2);
         memcpy(a1, a2, MD5_SIZE);
 
         /* work out the actual hash */
         hmac_md5(a1, MD5_SIZE+seed_len, sec, sec_len, out);
     }
 }
 
 /**
  * Work out the SHA1 PRF.
  */
 static void p_hash_sha1(const uint8_t *sec, int sec_len, 
         uint8_t *seed, int seed_len, uint8_t *out, int olen)
 {
     uint8_t a1[128];
 
     /* A(1) */
     hmac_sha1(seed, seed_len, sec, sec_len, a1);
     memcpy(&a1[SHA1_SIZE], seed, seed_len);
     hmac_sha1(a1, SHA1_SIZE+seed_len, sec, sec_len, out);
 
     while (olen > SHA1_SIZE)
     {
         uint8_t a2[SHA1_SIZE];
         out += SHA1_SIZE;
         olen -= SHA1_SIZE;
 
         /* A(N) */
         hmac_sha1(a1, SHA1_SIZE, sec, sec_len, a2);
         memcpy(a1, a2, SHA1_SIZE);
 
         /* work out the actual hash */
         hmac_sha1(a1, SHA1_SIZE+seed_len, sec, sec_len, out);
     }
 }
 
 /**
  * Work out the PRF.
  */
 static void prf(const uint8_t *sec, int sec_len, uint8_t *seed, int seed_len,
         uint8_t *out, int olen)
 {
     int len, i;
     const uint8_t *S1, *S2;
     uint8_t xbuf[256]; /* needs to be > the amount of key data */
     uint8_t ybuf[256]; /* needs to be > the amount of key data */
 
     len = sec_len/2;
     S1 = sec;
     S2 = &sec[len];
     len += (sec_len & 1); /* add for odd, make longer */
 
     p_hash_md5(S1, len, seed, seed_len, xbuf, olen);
     p_hash_sha1(S2, len, seed, seed_len, ybuf, olen);
 
     for (i = 0; i < olen; i++)
         out[i] = xbuf[i] ^ ybuf[i];
 }
 
 /**
  * Generate a master secret based on the client/server random data and the
  * premaster secret.
  */
 void generate_master_secret(SSL *ssl, const uint8_t *premaster_secret)
 {
     uint8_t buf[128];   /* needs to be > 13+32+32 in size */
     strcpy((char *)buf, "master secret");
     memcpy(&buf[13], ssl->dc->client_random, SSL_RANDOM_SIZE);
     memcpy(&buf[45], ssl->dc->server_random, SSL_RANDOM_SIZE);
     prf(premaster_secret, SSL_SECRET_SIZE, buf, 77, ssl->dc->master_secret,
             SSL_SECRET_SIZE);
 }
 
 /**
  * Generate a 'random' blob of data used for the generation of keys.
  */
 static void generate_key_block(uint8_t *client_random, uint8_t *server_random,
         uint8_t *master_secret, uint8_t *key_block, int key_block_size)
 {
     uint8_t buf[128];
     strcpy((char *)buf, "key expansion");
     memcpy(&buf[13], server_random, SSL_RANDOM_SIZE);
     memcpy(&buf[45], client_random, SSL_RANDOM_SIZE);
     prf(master_secret, SSL_SECRET_SIZE, buf, 77, key_block, key_block_size);
 }
 
 /** 
  * Calculate the digest used in the finished message. This function also
  * doubles up as a certificate verify function.
  */
 void finished_digest(SSL *ssl, const char *label, uint8_t *digest)
 {
     uint8_t mac_buf[128]; 
     uint8_t *q = mac_buf;
     MD5_CTX md5_ctx = ssl->dc->md5_ctx;
     SHA1_CTX sha1_ctx = ssl->dc->sha1_ctx;
 
     if (label)
     {
         strcpy((char *)q, label);
         q += strlen(label);
     }
 
     MD5_Final(q, &md5_ctx);
     q += MD5_SIZE;
     
     SHA1_Final(q, &sha1_ctx);
     q += SHA1_SIZE;
 
     if (label)
     {
         prf(ssl->dc->master_secret, SSL_SECRET_SIZE, mac_buf, (int)(q-mac_buf),
             digest, SSL_FINISHED_HASH_SIZE);
     }
     else    /* for use in a certificate verify */
     {
         memcpy(digest, mac_buf, MD5_SIZE + SHA1_SIZE);
     }
 
 #if 0
     printf("label: %s\n", label);
     print_blob("master secret", ssl->dc->master_secret, 48);
     print_blob("mac_buf", mac_buf, q-mac_buf);
     print_blob("finished digest", digest, SSL_FINISHED_HASH_SIZE);
 #endif
 }   
     
 /**
  * Retrieve (and initialise) the context of a cipher.
  */
 static void *crypt_new(SSL *ssl, uint8_t *key, uint8_t *iv, int is_decrypt)
 {
     switch (ssl->cipher)
     {
 #ifndef CONFIG_SSL_SKELETON_MODE
         case SSL_AES128_SHA:
             {
                 AES_CTX *aes_ctx = (AES_CTX *)malloc(sizeof(AES_CTX));
                 AES_set_key(aes_ctx, key, iv, AES_MODE_128);
 
                 if (is_decrypt)
                 {
                     AES_convert_key(aes_ctx);
                 }
 
                 return (void *)aes_ctx;
             }
 
         case SSL_AES256_SHA:
             {
                 AES_CTX *aes_ctx = (AES_CTX *)malloc(sizeof(AES_CTX));
                 AES_set_key(aes_ctx, key, iv, AES_MODE_256);
 
                 if (is_decrypt)
                 {
                     AES_convert_key(aes_ctx);
                 }
 
                 return (void *)aes_ctx;
             }
 
         case SSL_RC4_128_MD5:
 #endif
         case SSL_RC4_128_SHA:
             {
                 RC4_CTX *rc4_ctx = (RC4_CTX *)malloc(sizeof(RC4_CTX));
                 RC4_setup(rc4_ctx, key, 16);
                 return (void *)rc4_ctx;
             }
     }
 
     return NULL;    /* its all gone wrong */
 }
 
 /**
  * Send a packet over the socket.
  */
 static int send_raw_packet(SSL *ssl, uint8_t protocol)
 {
     uint8_t *rec_buf = ssl->bm_all_data;
     int pkt_size = SSL_RECORD_SIZE+ssl->bm_index;
     int sent = 0;
     int ret = SSL_OK;
 
     rec_buf[0] = protocol;
     rec_buf[1] = 0x03;      /* version = 3.1 (TLS) */
     rec_buf[2] = 0x01;
     rec_buf[3] = ssl->bm_index >> 8;
     rec_buf[4] = ssl->bm_index & 0xff;
 
     DISPLAY_BYTES(ssl, "sending %d bytes", ssl->bm_all_data, 
                              pkt_size, pkt_size);
 
     while (sent < pkt_size)
     {
         if ((ret = SOCKET_WRITE(ssl->client_fd, 
                         &ssl->bm_all_data[sent], pkt_size)) < 0)
         {
             ret = SSL_ERROR_CONN_LOST;
             break;
         }
 
         sent += ret;
 
         /* keep going until the write buffer has some space */
         if (sent != pkt_size)
         {
             fd_set wfds;
             FD_ZERO(&wfds);
             FD_SET(ssl->client_fd, &wfds);
 
             if (select(ssl->client_fd + 1, NULL, &wfds, NULL, NULL) < 0)
             {
                 ret = SSL_ERROR_CONN_LOST;
                 break;
             }
         }
     }
 
     SET_SSL_FLAG(SSL_NEED_RECORD);  /* reset for next time */
     ssl->bm_index = 0;
 
     if (protocol != PT_APP_PROTOCOL_DATA)  
     {
         /* always return SSL_OK during handshake */   
         ret = SSL_OK;
     }
 
     return ret;
 }
 
 /**
  * Send an encrypted packet with padding bytes if necessary.
  */
 int send_packet(SSL *ssl, uint8_t protocol, const uint8_t *in, int length)
 {
     int msg_length = length;
     int ret, pad_bytes = 0;
     ssl->bm_index = msg_length;
 
     /* if our state is bad, don't bother */
     if (ssl->hs_status == SSL_ERROR_DEAD)
         return SSL_ERROR_CONN_LOST;
 
     if (in) /* has the buffer already been initialised? */
     {
         memcpy(ssl->bm_data, in, length);
     }
 
     if (IS_SET_SSL_FLAG(SSL_TX_ENCRYPTED))
     {
         int mode = IS_SET_SSL_FLAG(SSL_IS_CLIENT) ? 
                             SSL_CLIENT_WRITE : SSL_SERVER_WRITE;
         uint8_t hmac_header[SSL_RECORD_SIZE];
 
         hmac_header[0] = protocol;
         hmac_header[1] = 0x03;
         hmac_header[2] = 0x01;
         hmac_header[3] = length >> 8; 
         hmac_header[4] = length & 0xff;
 
         if (protocol == PT_HANDSHAKE_PROTOCOL)
         {
             DISPLAY_STATE(ssl, 1, ssl->bm_data[0], 0);
 
             if (ssl->bm_data[0] != HS_HELLO_REQUEST)
             {
                 add_packet(ssl, ssl->bm_data, ssl->bm_index);
             }
         }
 
         /* add the packet digest */
         msg_length += ssl->cipher_info->digest_size;
         ssl->bm_index = msg_length;
         add_hmac_digest(ssl, mode, hmac_header, ssl->bm_data, length, 
                                                 &ssl->bm_data[length]);
 
         /* add padding? */
         if (ssl->cipher_info->padding_size)
         {
             int last_blk_size = msg_length%ssl->cipher_info->padding_size;
             pad_bytes = ssl->cipher_info->padding_size - last_blk_size;
 
             /* ensure we always have at least 1 padding byte */
             if (pad_bytes == 0)
                 pad_bytes += ssl->cipher_info->padding_size;
 
             memset(&ssl->bm_data[msg_length], pad_bytes-1, pad_bytes);
             msg_length += pad_bytes;
             ssl->bm_index = msg_length;
         }
 
         DISPLAY_BYTES(ssl, "unencrypted write", ssl->bm_data, msg_length);
         increment_write_sequence(ssl);
 
         /* now encrypt the packet */
         ssl->cipher_info->encrypt(ssl->encrypt_ctx, ssl->bm_data, 
                                             ssl->bm_data, msg_length);
     }
     else if (protocol == PT_HANDSHAKE_PROTOCOL)
     {
         DISPLAY_STATE(ssl, 1, ssl->bm_data[0], 0);
 
         if (ssl->bm_data[0] != HS_HELLO_REQUEST)
         {
             add_packet(ssl, ssl->bm_data, ssl->bm_index);
         }
     }
 
     if ((ret = send_raw_packet(ssl, protocol)) <= 0)
         return ret;
 
     return length;  /* just return what we wanted to send */
 }
 
 /**
  * Work out the cipher keys we are going to use for this session based on the
  * master secret.
  */
 static int set_key_block(SSL *ssl, int is_write)
 {
     const cipher_info_t *ciph_info = get_cipher_info(ssl->cipher);
     uint8_t *q;
     uint8_t client_key[32], server_key[32]; /* big enough for AES256 */
     uint8_t client_iv[16], server_iv[16];   /* big enough for AES128/256 */
     int is_client = IS_SET_SSL_FLAG(SSL_IS_CLIENT);
 
     if (ciph_info == NULL)
         return -1;
 
     /* only do once in a handshake */
     if (ssl->dc->key_block == NULL)
     {
         ssl->dc->key_block = (uint8_t *)malloc(ciph_info->key_block_size);
 
 #if 0
         print_blob("client", ssl->dc->client_random, 32);
         print_blob("server", ssl->dc->server_random, 32);
         print_blob("master", ssl->dc->master_secret, SSL_SECRET_SIZE);
 #endif
         generate_key_block(ssl->dc->client_random, ssl->dc->server_random,
             ssl->dc->master_secret, ssl->dc->key_block, 
             ciph_info->key_block_size);
 #if 0
         print_blob("keyblock", ssl->key_block, ciph_info->key_block_size);
 #endif
     }
 
     q = ssl->dc->key_block;
 
     if ((is_client && is_write) || (!is_client && !is_write))
     {
         memcpy(ssl->client_mac, q, ciph_info->digest_size);
     }
 
     q += ciph_info->digest_size;
 
     if ((!is_client && is_write) || (is_client && !is_write))
     {
         memcpy(ssl->server_mac, q, ciph_info->digest_size);
     }
 
     q += ciph_info->digest_size;
     memcpy(client_key, q, ciph_info->key_size);
     q += ciph_info->key_size;
     memcpy(server_key, q, ciph_info->key_size);
     q += ciph_info->key_size;
 
 #ifndef CONFIG_SSL_SKELETON_MODE 
     if (ciph_info->iv_size)    /* RC4 has no IV, AES does */
     {
         memcpy(client_iv, q, ciph_info->iv_size);
         q += ciph_info->iv_size;
         memcpy(server_iv, q, ciph_info->iv_size);
         q += ciph_info->iv_size;
     }
 #endif
 
     free(is_write ? ssl->encrypt_ctx : ssl->decrypt_ctx);
 
     /* now initialise the ciphers */
     if (is_client)
     {
         finished_digest(ssl, server_finished, ssl->dc->final_finish_mac);
 
         if (is_write)
             ssl->encrypt_ctx = crypt_new(ssl, client_key, client_iv, 0);
         else
             ssl->decrypt_ctx = crypt_new(ssl, server_key, server_iv, 1);
     }
     else
     {
         finished_digest(ssl, client_finished, ssl->dc->final_finish_mac);
 
         if (is_write)
             ssl->encrypt_ctx = crypt_new(ssl, server_key, server_iv, 0);
         else
             ssl->decrypt_ctx = crypt_new(ssl, client_key, client_iv, 1);
     }
 
     ssl->cipher_info = ciph_info;
     return 0;
 }
 
 /**
  * Read the SSL connection.
  */
 int basic_read(SSL *ssl, uint8_t **in_data)
 {
     int ret = SSL_OK;
     int read_len, is_client = IS_SET_SSL_FLAG(SSL_IS_CLIENT);
     uint8_t *buf = ssl->bm_data;
 
     read_len = SOCKET_READ(ssl->client_fd, &buf[ssl->bm_read_index], 
                             ssl->need_bytes-ssl->got_bytes);
 
     /* connection has gone, so die */
     if (read_len <= 0)
     {
         ret = SSL_ERROR_CONN_LOST;
         ssl->hs_status = SSL_ERROR_DEAD;  /* make sure it stays dead */
         goto error;
     }
 
     DISPLAY_BYTES(ssl, "received %d bytes", 
             &ssl->bm_data[ssl->bm_read_index], read_len, read_len);
 
     ssl->got_bytes += read_len;
     ssl->bm_read_index += read_len;
 
     /* haven't quite got what we want, so try again later */
     if (ssl->got_bytes < ssl->need_bytes)
         return SSL_OK;
 
     read_len = ssl->got_bytes;
     ssl->got_bytes = 0;
 
     if (IS_SET_SSL_FLAG(SSL_NEED_RECORD))
     {
         /* check for sslv2 "client hello" */
         if (buf[0] & 0x80 && buf[2] == 1 && buf[3] == 0x03)
         {
 #ifdef CONFIG_SSL_ENABLE_V23_HANDSHAKE
             DISPLAY_BYTES(ssl, "ssl2 record", buf, 5);
             add_packet(ssl, &buf[2], 3);
             ret = process_sslv23_client_hello(ssl); 
 #else
             printf("Error: no SSLv23 handshaking allowed\n"); TTY_FLUSH();
             ret = SSL_ERROR_NOT_SUPPORTED;
 #endif
             goto error; /* not an error - just get out of here */
         }
 
         ssl->need_bytes = (buf[3] << 8) + buf[4];
 
         /* do we violate the spec with the message size?  */
         if (ssl->need_bytes > RT_MAX_PLAIN_LENGTH+RT_EXTRA-BM_RECORD_OFFSET)
         {
             ret = SSL_ERROR_INVALID_PROT_MSG;              
             goto error;
         }
 
         CLR_SSL_FLAG(SSL_NEED_RECORD);
         memcpy(ssl->hmac_header, buf, 3);       /* store for hmac */
         ssl->record_type = buf[0];
         goto error;                         /* no error, we're done */
     }
 
     /* for next time - just do it now in case of an error */
     SET_SSL_FLAG(SSL_NEED_RECORD);
     ssl->need_bytes = SSL_RECORD_SIZE;
 
     /* decrypt if we need to */
     if (IS_SET_SSL_FLAG(SSL_RX_ENCRYPTED))
     {
         ssl->cipher_info->decrypt(ssl->decrypt_ctx, buf, buf, read_len);
         read_len = verify_digest(ssl, 
                 is_client ? SSL_CLIENT_READ : SSL_SERVER_READ, buf, read_len);
 
         /* does the hmac work? */
         if (read_len < 0)
         {
             ret = read_len;
             goto error;
         }
 
         DISPLAY_BYTES(ssl, "decrypted", buf, read_len);
         increment_read_sequence(ssl);
     }
 
     /* The main part of the SSL packet */
     switch (ssl->record_type)
     {
         case PT_HANDSHAKE_PROTOCOL:
             if (ssl->dc != NULL)
             {
                 ssl->dc->bm_proc_index = 0;
                 ret = do_handshake(ssl, buf, read_len);
             }
-            else /* no client renegotiation allowed */
+            else /* no client renogiation allowed */
             {
                 ret = SSL_ERROR_NO_CLIENT_RENOG;              
                 goto error;
             }
             break;
 
         case PT_CHANGE_CIPHER_SPEC:
             if (ssl->next_state != HS_FINISHED)
             {
                 ret = SSL_ERROR_INVALID_HANDSHAKE;
                 goto error;
             }
 
             /* all encrypted from now on */
             SET_SSL_FLAG(SSL_RX_ENCRYPTED);
             if (set_key_block(ssl, 0) < 0)
             {
                 ret = SSL_ERROR_INVALID_HANDSHAKE;
                 goto error;
             }
             
             memset(ssl->read_sequence, 0, 8);
             break;
 
         case PT_APP_PROTOCOL_DATA:
             if (in_data)
             {
                 *in_data = ssl->bm_data;   /* point to the work buffer */
                 (*in_data)[read_len] = 0;  /* null terminate just in case */
             }
 
             ret = read_len;
             break;
 
         case PT_ALERT_PROTOCOL:
             /* return the alert # with alert bit set */
             ret = -buf[1]; 
             DISPLAY_ALERT(ssl, buf[1]);
             break;
 
         default:
             ret = SSL_ERROR_INVALID_PROT_MSG;
             break;
     }
 
 error:
     ssl->bm_read_index = 0;          /* reset to go again */
 
     if (ret < SSL_OK && in_data)/* if all wrong, then clear this buffer ptr */
         *in_data = NULL;
 
     return ret;
 }
 
 /**
  * Do some basic checking of data and then perform the appropriate handshaking.
  */
 static int do_handshake(SSL *ssl, uint8_t *buf, int read_len)
 {
     int hs_len = (buf[2]<<8) + buf[3];
     uint8_t handshake_type = buf[0];
     int ret = SSL_OK;
     int is_client = IS_SET_SSL_FLAG(SSL_IS_CLIENT);
 
     /* some integrity checking on the handshake */
     PARANOIA_CHECK(read_len-SSL_HS_HDR_SIZE, hs_len);
 
     if (handshake_type != ssl->next_state)
     {
         /* handle a special case on the client */
         if (!is_client || handshake_type != HS_CERT_REQ ||
                         ssl->next_state != HS_SERVER_HELLO_DONE)
         {
             ret = SSL_ERROR_INVALID_HANDSHAKE;
             goto error;
         }
     }
 
     hs_len += SSL_HS_HDR_SIZE;  /* adjust for when adding packets */
     ssl->bm_index = hs_len;     /* store the size and check later */
     DISPLAY_STATE(ssl, 0, handshake_type, 0);
 
     if (handshake_type != HS_CERT_VERIFY && handshake_type != HS_HELLO_REQUEST)
         add_packet(ssl, buf, hs_len); 
 
 #if defined(CONFIG_SSL_ENABLE_CLIENT)
     ret = is_client ? 
         do_clnt_handshake(ssl, handshake_type, buf, hs_len) :
         do_svr_handshake(ssl, handshake_type, buf, hs_len);
 #else
     ret = do_svr_handshake(ssl, handshake_type, buf, hs_len);
 #endif
 
     /* just use recursion to get the rest */
     if (hs_len < read_len && ret == SSL_OK)
         ret = do_handshake(ssl, &buf[hs_len], read_len-hs_len);
 
 error:
     return ret;
 }
 
 /**
  * Sends the change cipher spec message. We have just read a finished message
  * from the client.
  */
 int send_change_cipher_spec(SSL *ssl)
 {
     int ret = send_packet(ssl, PT_CHANGE_CIPHER_SPEC, 
             g_chg_cipher_spec_pkt, sizeof(g_chg_cipher_spec_pkt));
     SET_SSL_FLAG(SSL_TX_ENCRYPTED);
 
     if (ret >= 0 && set_key_block(ssl, 1) < 0)
         ret = SSL_ERROR_INVALID_HANDSHAKE;
 
     memset(ssl->write_sequence, 0, 8);
     return ret;
 }
 
 /**
  * Send a "finished" message
  */
 int send_finished(SSL *ssl)
 {
     uint8_t *buf = ssl->bm_data;
 
     buf[0] = HS_FINISHED;
     buf[1] = 0;
     buf[2] = 0;
     buf[3] = SSL_FINISHED_HASH_SIZE;
 
     /* now add the finished digest mac (12 bytes) */
     finished_digest(ssl, 
         IS_SET_SSL_FLAG(SSL_IS_CLIENT) ?
                     client_finished : server_finished, &buf[4]);
 
 #ifndef CONFIG_SSL_SKELETON_MODE
     /* store in the session cache */
     if (!IS_SET_SSL_FLAG(SSL_SESSION_RESUME) && ssl->ssl_ctx->num_sessions)
     {
         memcpy(ssl->session->master_secret,
                 ssl->dc->master_secret, SSL_SECRET_SIZE);
     }
 #endif
 
     return send_packet(ssl, PT_HANDSHAKE_PROTOCOL,
                                 NULL, SSL_FINISHED_HASH_SIZE+4);
 }
 
 /**
  * Send an alert message.
  * Return 1 if the alert was an "error".
  */
 int send_alert(SSL *ssl, int error_code)
 {
     int alert_num = 0;
     int is_warning = 0;
     uint8_t buf[2];
 
     /* Don't bother we're already dead */
     if (ssl->hs_status == SSL_ERROR_DEAD)
     {
         return SSL_ERROR_CONN_LOST;
     }
 
 #ifdef CONFIG_SSL_FULL_MODE
     if (IS_SET_SSL_FLAG(SSL_DISPLAY_STATES))
         ssl_display_error(error_code);
 #endif
 
     switch (error_code)
     {
         case SSL_ALERT_CLOSE_NOTIFY:
             is_warning = 1;
             alert_num = SSL_ALERT_CLOSE_NOTIFY;
             break;
 
         case SSL_ERROR_CONN_LOST:       /* don't send alert just yet */
             is_warning = 1;
             break;
 
         case SSL_ERROR_INVALID_HANDSHAKE:
         case SSL_ERROR_INVALID_PROT_MSG:
             alert_num = SSL_ALERT_HANDSHAKE_FAILURE;
             break;
 
         case SSL_ERROR_INVALID_HMAC:
         case SSL_ERROR_FINISHED_INVALID:
             alert_num = SSL_ALERT_BAD_RECORD_MAC;
             break;
 
         case SSL_ERROR_INVALID_VERSION:
             alert_num = SSL_ALERT_INVALID_VERSION;
             break;
 
         case SSL_ERROR_INVALID_SESSION:
         case SSL_ERROR_NO_CIPHER:
         case SSL_ERROR_INVALID_KEY:
             alert_num = SSL_ALERT_ILLEGAL_PARAMETER;
             break;
 
         case SSL_ERROR_BAD_CERTIFICATE:
             alert_num = SSL_ALERT_BAD_CERTIFICATE;
             break;
 
         case SSL_ERROR_NO_CLIENT_RENOG:
             alert_num = SSL_ALERT_NO_RENEGOTIATION;
             break;
 
         default:
             /* a catch-all for any badly verified certificates */
             alert_num = (error_code <= SSL_X509_OFFSET) ?  
                 SSL_ALERT_BAD_CERTIFICATE : SSL_ALERT_UNEXPECTED_MESSAGE;
             break;
     }
 
     buf[0] = is_warning ? 1 : 2;
     buf[1] = alert_num;
     send_packet(ssl, PT_ALERT_PROTOCOL, buf, sizeof(buf));
     DISPLAY_ALERT(ssl, alert_num);
     return is_warning ? 0 : 1;
 }
 
 /**
  * Process a client finished message.
  */
 int process_finished(SSL *ssl, int hs_len)
 {
     uint8_t *buf = ssl->bm_data;
     int ret = SSL_OK;
     int is_client = IS_SET_SSL_FLAG(SSL_IS_CLIENT);
     int resume = IS_SET_SSL_FLAG(SSL_SESSION_RESUME);
 
     PARANOIA_CHECK(ssl->bm_index, SSL_FINISHED_HASH_SIZE+4);
 
     /* check that we all work before we continue */
     if (memcmp(ssl->dc->final_finish_mac, &buf[4], SSL_FINISHED_HASH_SIZE))
         return SSL_ERROR_FINISHED_INVALID;
 
     if ((!is_client && !resume) || (is_client && resume))
     {
         if ((ret = send_change_cipher_spec(ssl)) == SSL_OK)
             ret = send_finished(ssl);
     }
 
     /* if we ever renegotiate */
     ssl->next_state = is_client ? HS_HELLO_REQUEST : HS_CLIENT_HELLO;  
     ssl->hs_status = ret;  /* set the final handshake status */
 
 error:
     return ret;
 }
 
 /**
  * Send a certificate.
  */
 int send_certificate(SSL *ssl)
 {
     int i = 0;
     uint8_t *buf = ssl->bm_data;
     int offset = 7;
     int chain_length;
 
     buf[0] = HS_CERTIFICATE;
     buf[1] = 0;
     buf[4] = 0;
 
     while (i < ssl->ssl_ctx->chain_length)
     {
         SSL_CERT *cert = &ssl->ssl_ctx->certs[i];
         buf[offset++] = 0;        
         buf[offset++] = cert->size >> 8;        /* cert 1 length */
         buf[offset++] = cert->size & 0xff;
         memcpy(&buf[offset], cert->buf, cert->size);
         offset += cert->size;
         i++;
     }
 
     chain_length = offset - 7;
     buf[5] = chain_length >> 8;        /* cert chain length */
     buf[6] = chain_length & 0xff;
     chain_length += 3;
     buf[2] = chain_length >> 8;        /* handshake length */
     buf[3] = chain_length & 0xff;
     ssl->bm_index = offset;
     return send_packet(ssl, PT_HANDSHAKE_PROTOCOL, NULL, offset);
 }
 
 /**
  * Create a blob of memory that we'll get rid of once the handshake is
  * complete.
  */
 void disposable_new(SSL *ssl)
 {
     if (ssl->dc == NULL)
     {
         ssl->dc = (DISPOSABLE_CTX *)calloc(1, sizeof(DISPOSABLE_CTX));
         MD5_Init(&ssl->dc->md5_ctx);
         SHA1_Init(&ssl->dc->sha1_ctx);
     }
 }
 
 /**
  * Remove the temporary blob of memory.
  */
 void disposable_free(SSL *ssl)
 {
     if (ssl->dc)
     {
         free(ssl->dc->key_block);
         memset(ssl->dc, 0, sizeof(DISPOSABLE_CTX));
         free(ssl->dc);
         ssl->dc = NULL;
     }
 
 }
 
 #ifndef CONFIG_SSL_SKELETON_MODE     /* no session resumption in this mode */
 /**
  * Find if an existing session has the same session id. If so, use the
  * master secret from this session for session resumption.
  */
 SSL_SESSION *ssl_session_update(int max_sessions, SSL_SESSION *ssl_sessions[], 
         SSL *ssl, const uint8_t *session_id)
 {
     time_t tm = time(NULL);
     time_t oldest_sess_time = tm;
     SSL_SESSION *oldest_sess = NULL;
     int i;
 
     /* no sessions? Then bail */
     if (max_sessions == 0)
         return NULL;
 
     SSL_CTX_LOCK(ssl->ssl_ctx->mutex);
     if (session_id)
     {
         for (i = 0; i < max_sessions; i++)
         {
             if (ssl_sessions[i])
             {
                 /* kill off any expired sessions */
                 if (tm > ssl_sessions[i]->conn_time + SSL_EXPIRY_TIME)
                 {
                     session_free(ssl_sessions, i);
                     continue;
                 }
 
                 /* if the session id matches, it must still be less than 
                    the expiry time */
                 if (memcmp(ssl_sessions[i]->session_id, session_id,
                                                 SSL_SESSION_ID_SIZE) == 0)
                 {
                     ssl->session_index = i;
                     memcpy(ssl->dc->master_secret, 
                             ssl_sessions[i]->master_secret, SSL_SECRET_SIZE);
                     SET_SSL_FLAG(SSL_SESSION_RESUME);
                     SSL_CTX_UNLOCK(ssl->ssl_ctx->mutex);
                     return ssl_sessions[i];  /* a session was found */
                 }
             }
         }
     }
 
     /* If we've got here, no matching session was found - so create one */
     for (i = 0; i < max_sessions; i++)
     {
         if (ssl_sessions[i] == NULL)
         {
             /* perfect, this will do */
             ssl_sessions[i] = (SSL_SESSION *)calloc(1, sizeof(SSL_SESSION));
             ssl_sessions[i]->conn_time = tm;
             ssl->session_index = i;
             SSL_CTX_UNLOCK(ssl->ssl_ctx->mutex);
             return ssl_sessions[i]; /* return the session object */
         }
         else if (ssl_sessions[i]->conn_time <= oldest_sess_time)
         {
             /* find the oldest session */
             oldest_sess_time = ssl_sessions[i]->conn_time;
             oldest_sess = ssl_sessions[i];
             ssl->session_index = i;
         }
     }
 
     /* ok, we've used up all of our sessions. So blow the oldest session away */
     oldest_sess->conn_time = tm;
     memset(oldest_sess->session_id, 0, sizeof(SSL_SESSION_ID_SIZE));
     memset(oldest_sess->master_secret, 0, sizeof(SSL_SECRET_SIZE));
     SSL_CTX_UNLOCK(ssl->ssl_ctx->mutex);
     return oldest_sess;
 }
 
 /**
  * Free an existing session.
  */
 static void session_free(SSL_SESSION *ssl_sessions[], int sess_index)
 {
     if (ssl_sessions[sess_index])
     {
         free(ssl_sessions[sess_index]);
         ssl_sessions[sess_index] = NULL;
     }
 }
 
 /**
  * This ssl object doesn't want this session anymore.
  */
 void kill_ssl_session(SSL_SESSION **ssl_sessions, SSL *ssl)
 {
     SSL_CTX_LOCK(ssl->ssl_ctx->mutex);
 
     if (ssl->ssl_ctx->num_sessions)
     {
         session_free(ssl_sessions, ssl->session_index);
         ssl->session = NULL;
     }
 
     SSL_CTX_UNLOCK(ssl->ssl_ctx->mutex);
 }
 #endif /* CONFIG_SSL_SKELETON_MODE */
 
 /*
  * Get the session id for a handshake. This will be a 32 byte sequence.
  */
 EXP_FUNC const uint8_t * STDCALL ssl_get_session_id(const SSL *ssl)
 {
     return ssl->session_id;
 }
 
 /*
  * Get the session id size for a handshake. 
  */
 EXP_FUNC uint8_t STDCALL ssl_get_session_id_size(const SSL *ssl)
 {
     return ssl->sess_id_size;
 }
 
 /*
  * Return the cipher id (in the SSL form).
  */
 EXP_FUNC uint8_t STDCALL ssl_get_cipher_id(const SSL *ssl)
 {
     return ssl->cipher;
 }
 
 /*
  * Return the status of the handshake.
  */
 EXP_FUNC int STDCALL ssl_handshake_status(const SSL *ssl)
 {
     return ssl->hs_status;
 }
 
 /*
  * Retrieve various parameters about the SSL engine.
  */
 EXP_FUNC int STDCALL ssl_get_config(int offset)
 {
     switch (offset)
     {
         /* return the appropriate build mode */
         case SSL_BUILD_MODE:
 #if defined(CONFIG_SSL_FULL_MODE)
             return SSL_BUILD_FULL_MODE;
 #elif defined(CONFIG_SSL_ENABLE_CLIENT)
             return SSL_BUILD_ENABLE_CLIENT;
 #elif defined(CONFIG_ENABLE_VERIFICATION)
             return SSL_BUILD_ENABLE_VERIFICATION;
 #elif defined(CONFIG_SSL_SERVER_ONLY )
             return SSL_BUILD_SERVER_ONLY;
 #else 
             return SSL_BUILD_SKELETON_MODE;
 #endif
 
         case SSL_MAX_CERT_CFG_OFFSET:
             return CONFIG_SSL_MAX_CERTS;
 
 #ifdef CONFIG_SSL_CERT_VERIFICATION
         case SSL_MAX_CA_CERT_CFG_OFFSET:
             return CONFIG_X509_MAX_CA_CERTS;
 #endif
 #ifdef CONFIG_SSL_HAS_PEM
         case SSL_HAS_PEM:
             return 1;
 #endif
         default:
             return 0;
     }
 }
 
 #ifdef CONFIG_SSL_CERT_VERIFICATION
 /**
  * Authenticate a received certificate.
  */
 EXP_FUNC int STDCALL ssl_verify_cert(const SSL *ssl)
 {
     int ret;
     SSL_CTX_LOCK(ssl->ssl_ctx->mutex);
     ret = x509_verify(ssl->ssl_ctx->ca_cert_ctx, ssl->x509_ctx);
     SSL_CTX_UNLOCK(ssl->ssl_ctx->mutex);
 
     if (ret)        /* modify into an SSL error type */
     {
         ret = SSL_X509_ERROR(ret);
     }
 
     return ret;
 }
 
 /**
  * Process a certificate message.
  */
 int process_certificate(SSL *ssl, X509_CTX **x509_ctx)
 {
     int ret = SSL_OK;
     uint8_t *buf = &ssl->bm_data[ssl->dc->bm_proc_index];
     int pkt_size = ssl->bm_index;
     int cert_size, offset = 5;
     int total_cert_size = (buf[offset]<<8) + buf[offset+1];
     int is_client = IS_SET_SSL_FLAG(SSL_IS_CLIENT);
     X509_CTX **chain = x509_ctx;
     offset += 2;
 
     PARANOIA_CHECK(total_cert_size, offset);
 
     while (offset < total_cert_size)
     {
         offset++;       /* skip empty char */
         cert_size = (buf[offset]<<8) + buf[offset+1];
         offset += 2;
         
         if (x509_new(&buf[offset], NULL, chain))
         {
             ret = SSL_ERROR_BAD_CERTIFICATE;
             goto error;
         }
 
         /* DISPLAY_CERT(ssl, *chain); */
         chain = &((*chain)->next);
         offset += cert_size;
     }
 
     PARANOIA_CHECK(pkt_size, offset);
 
     /* if we are client we can do the verify now or later */
     if (is_client && !IS_SET_SSL_FLAG(SSL_SERVER_VERIFY_LATER))
     {
         ret = ssl_verify_cert(ssl);
     }
 
     ssl->next_state = is_client ? HS_SERVER_HELLO_DONE : HS_CLIENT_KEY_XCHG;
     ssl->dc->bm_proc_index += offset;
 error:
     return ret;
 }
 
 #endif /* CONFIG_SSL_CERT_VERIFICATION */
 
 /**
  * Debugging routine to display SSL handshaking stuff.
  */
 #ifdef CONFIG_SSL_FULL_MODE
 /**
  * Debugging routine to display SSL states.
  */
 void DISPLAY_STATE(SSL *ssl, int is_send, uint8_t state, int not_ok)
 {
     const char *str;
 
     if (!IS_SET_SSL_FLAG(SSL_DISPLAY_STATES))
         return;
 
     printf(not_ok ? "Error - invalid State:\t" : "State:\t");
     printf(is_send ? "sending " : "receiving ");
 
     switch (state)
     {
         case HS_HELLO_REQUEST:
             str = "Hello Request (0)";
             break;
 
         case HS_CLIENT_HELLO:
             str = "Client Hello (1)";
             break;
 
         case HS_SERVER_HELLO:
             str = "Server Hello (2)";
             break;
 
         case HS_CERTIFICATE:
             str = "Certificate (11)";
             break;
 
         case HS_SERVER_KEY_XCHG:
             str = "Certificate Request (12)";
             break;
 
         case HS_CERT_REQ:
             str = "Certificate Request (13)";
             break;
 
         case HS_SERVER_HELLO_DONE:
             str = "Server Hello Done (14)";
             break;
 
         case HS_CERT_VERIFY:
             str = "Certificate Verify (15)";
             break;
 
         case HS_CLIENT_KEY_XCHG:
             str = "Client Key Exchange (16)";
             break;
 
         case HS_FINISHED:
             str = "Finished (16)";
             break;
 
         default:
             str = "Error (Unknown)";
             
             break;
     }
 
     printf("%s\n", str);
     TTY_FLUSH();
 }
 
 /**
  * Debugging routine to display X509 certificates.
  */
 void DISPLAY_CERT(SSL *ssl, const X509_CTX *x509_ctx)
 {
     if (!IS_SET_SSL_FLAG(SSL_DISPLAY_CERTS))
         return;
 
     x509_print(x509_ctx, ssl->ssl_ctx->ca_cert_ctx);
     TTY_FLUSH();
 }
 
 /**
  * Debugging routine to display RSA objects
  */
 void DISPLAY_RSA(SSL *ssl, const RSA_CTX *rsa_ctx)
 {
     if (!IS_SET_SSL_FLAG(SSL_DISPLAY_RSA))
         return;
 
     RSA_print(rsa_ctx);
     TTY_FLUSH();
 }
 
 /**
  * Debugging routine to display SSL handshaking bytes.
  */
 void DISPLAY_BYTES(SSL *ssl, const char *format, 
         const uint8_t *data, int size, ...)
 {
     va_list(ap);
 
     if (!IS_SET_SSL_FLAG(SSL_DISPLAY_BYTES))
         return;
 
     va_start(ap, size);
     print_blob(format, data, size, va_arg(ap, char *));
     va_end(ap);
     TTY_FLUSH();
 }
 
 /**
  * Debugging routine to display SSL handshaking errors.
  */
 EXP_FUNC void STDCALL ssl_display_error(int error_code)
 {
     if (error_code == SSL_OK)
         return;
 
     printf("Error: ");
 
     /* X509 error? */
     if (error_code < SSL_X509_OFFSET)
     {
         printf("%s\n", x509_display_error(error_code - SSL_X509_OFFSET));
         return;
     }
 
     /* SSL alert error code */
     if (error_code > SSL_ERROR_CONN_LOST)
     {
         printf("SSL error %d\n", -error_code);
         return;
     }
 
     switch (error_code)
     {
         case SSL_ERROR_DEAD:
             printf("connection dead");
             break;
 
         case SSL_ERROR_INVALID_HANDSHAKE:
             printf("invalid handshake");
             break;
 
         case SSL_ERROR_INVALID_PROT_MSG:
             printf("invalid protocol message");
             break;
 
         case SSL_ERROR_INVALID_HMAC:
             printf("invalid mac");
             break;
 
         case SSL_ERROR_INVALID_VERSION:
             printf("invalid version");
             break;
 
         case SSL_ERROR_INVALID_SESSION:
             printf("invalid session");
             break;
 
         case SSL_ERROR_NO_CIPHER:
             printf("no cipher");
             break;
 
         case SSL_ERROR_CONN_LOST:
             printf("connection lost");
             break;
 
         case SSL_ERROR_BAD_CERTIFICATE:
             printf("bad certificate");
             break;
 
         case SSL_ERROR_INVALID_KEY:
             printf("invalid key");
             break;
 
         case SSL_ERROR_FINISHED_INVALID:
             printf("finished invalid");
             break;
 
         case SSL_ERROR_NO_CERT_DEFINED:
             printf("no certificate defined");
             break;
 
         case SSL_ERROR_NO_CLIENT_RENOG:
             printf("client renegotiation not supported");
             break;
             
         case SSL_ERROR_NOT_SUPPORTED:
             printf("Option not supported");
             break;
 
         default:
             printf("undefined as yet - %d", error_code);
             break;
     }
 
     printf("\n");
     TTY_FLUSH();
 }
 
 /**
  * Debugging routine to display alerts.
  */
 void DISPLAY_ALERT(SSL *ssl, int alert)
 {
     if (!IS_SET_SSL_FLAG(SSL_DISPLAY_STATES))
         return;
 
     printf("Alert: ");
 
     switch (alert)
     {
         case SSL_ALERT_CLOSE_NOTIFY:
             printf("close notify");
             break;
 
         case SSL_ALERT_INVALID_VERSION:
             printf("invalid version");
             break;
 
         case SSL_ALERT_BAD_CERTIFICATE:
             printf("bad certificate");
             break;
 
         case SSL_ALERT_UNEXPECTED_MESSAGE:
             printf("unexpected message");
             break;
 
         case SSL_ALERT_BAD_RECORD_MAC:
             printf("bad record mac");
             break;
 
         case SSL_ALERT_HANDSHAKE_FAILURE:
             printf("handshake failure");
             break;
 
         case SSL_ALERT_ILLEGAL_PARAMETER:
             printf("illegal parameter");
             break;
 
         case SSL_ALERT_DECODE_ERROR:
             printf("decode error");
             break;
 
         case SSL_ALERT_DECRYPT_ERROR:
             printf("decrypt error");
             break;
 
         case SSL_ALERT_NO_RENEGOTIATION:
             printf("no renegotiation");
             break;
 
         default:
             printf("alert - (unknown %d)", alert);
             break;
     }
 
     printf("\n");
     TTY_FLUSH();
 }
 
 #endif /* CONFIG_SSL_FULL_MODE */
 
 /**
  * Return the version of this library.
  */
 EXP_FUNC const char  * STDCALL ssl_version()
 {
     static const char * axtls_version = AXTLS_VERSION;
     return axtls_version;
 }
 
 /**
  * Enable the various language bindings to work regardless of the
  * configuration - they just return an error statement and a bad return code.
  */
 #if !defined(CONFIG_SSL_FULL_MODE)
 EXP_FUNC void STDCALL ssl_display_error(int error_code) {}
 #endif
 
 #ifdef CONFIG_BINDINGS
 #if !defined(CONFIG_SSL_ENABLE_CLIENT)
 EXP_FUNC SSL * STDCALL ssl_client_new(SSL_CTX *ssl_ctx, int client_fd, const
         uint8_t *session_id, uint8_t sess_id_size)
 {
     printf(unsupported_str);
     return NULL;
 }
 #endif
 
 #if !defined(CONFIG_SSL_CERT_VERIFICATION)
 EXP_FUNC int STDCALL ssl_verify_cert(const SSL *ssl)
 {
     printf(unsupported_str);
     return -1;
 }
 
 
 EXP_FUNC const char * STDCALL ssl_get_cert_dn(const SSL *ssl, int component)
 {
     printf(unsupported_str);
     return NULL;
 }
 
 EXP_FUNC const char * STDCALL ssl_get_cert_subject_alt_dnsname(const SSL *ssl, int index)
 {
     printf(unsupported_str);
     return NULL;
 }
 
 #endif  /* CONFIG_SSL_CERT_VERIFICATION */
 
 #endif /* CONFIG_BINDINGS */
 
Index: ssl/tls1_clnt.c
===================================================================
--- ssl/tls1_clnt.c	(revision 176)
+++ ssl/tls1_clnt.c	(revision 175)
@@ -1,386 +1,387 @@
 /*
  * Copyright (c) 2007, Cameron Rich
  * 
  * All rights reserved.
  * 
  * Redistribution and use in source and binary forms, with or without 
  * modification, are permitted provided that the following conditions are met:
  *
  * * Redistributions of source code must retain the above copyright notice, 
  *   this list of conditions and the following disclaimer.
  * * Redistributions in binary form must reproduce the above copyright notice, 
  *   this list of conditions and the following disclaimer in the documentation 
  *   and/or other materials provided with the distribution.
  * * Neither the name of the axTLS project nor the names of its contributors 
  *   may be used to endorse or promote products derived from this software 
  *   without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #include <stdlib.h>
 #include <string.h>
 #include <time.h>
 #include <stdio.h>
 
 #include "ssl.h"
 
 #ifdef CONFIG_SSL_ENABLE_CLIENT        /* all commented out if no client */
 
 static int send_client_hello(SSL *ssl);
 static int process_server_hello(SSL *ssl);
 static int process_server_hello_done(SSL *ssl);
 static int send_client_key_xchg(SSL *ssl);
 static int process_cert_req(SSL *ssl);
 static int send_cert_verify(SSL *ssl);
 
 /*
  * Establish a new SSL connection to an SSL server.
  */
 EXP_FUNC SSL * STDCALL ssl_client_new(SSL_CTX *ssl_ctx, int client_fd, const
         uint8_t *session_id, uint8_t sess_id_size)
 {
     SSL *ssl;
     int ret;
 
     SOCKET_BLOCK(client_fd);    /* ensure blocking mode */
     ssl = ssl_new(ssl_ctx, client_fd);
 
     if (session_id && ssl_ctx->num_sessions)
     {
         if (sess_id_size > SSL_SESSION_ID_SIZE) /* validity check */
         {
             ssl_free(ssl);
             return NULL;
         }
 
         memcpy(ssl->session_id, session_id, sess_id_size);
         ssl->sess_id_size = sess_id_size;
         SET_SSL_FLAG(SSL_SESSION_RESUME);   /* just flag for later */
     }
 
     SET_SSL_FLAG(SSL_IS_CLIENT);
     ret = do_client_connect(ssl);
     return ssl;
 }
 
 /*
  * Process the handshake record.
  */
 int do_clnt_handshake(SSL *ssl, int handshake_type, uint8_t *buf, int hs_len)
 {
     int ret = SSL_OK;
 
     /* To get here the state must be valid */
     switch (handshake_type)
     {
         case HS_SERVER_HELLO:
             ret = process_server_hello(ssl);
             break;
 
         case HS_CERTIFICATE:
             ret = process_certificate(ssl, &ssl->x509_ctx);
             break;
 
         case HS_SERVER_HELLO_DONE:
             if ((ret = process_server_hello_done(ssl)) == SSL_OK)
             {
                 if (IS_SET_SSL_FLAG(SSL_HAS_CERT_REQ))
                 {
                     if ((ret = send_certificate(ssl)) == SSL_OK &&
                         (ret = send_client_key_xchg(ssl)) == SSL_OK)
                     {
                         send_cert_verify(ssl);
                     }
                 }
                 else
                 {
                     ret = send_client_key_xchg(ssl);
                 }
 
                 if (ret == SSL_OK && 
                      (ret = send_change_cipher_spec(ssl)) == SSL_OK)
                 {
                     ret = send_finished(ssl);
                 }
             }
             break;
 
         case HS_CERT_REQ:
             ret = process_cert_req(ssl);
             break;
 
         case HS_FINISHED:
             ret = process_finished(ssl, hs_len);
             disposable_free(ssl);   /* free up some memory */
-            /* note: client renegotiation is not allowed after this */
+            /* note: client renogiation is not allowed after this */
             break;
 
         case HS_HELLO_REQUEST:
             disposable_new(ssl);
             ret = do_client_connect(ssl);
             break;
     }
 
     return ret;
 }
 
 /*
  * Do the handshaking from the beginning.
  */
 int do_client_connect(SSL *ssl)
 {
     int ret = SSL_OK;
 
     send_client_hello(ssl);                 /* send the client hello */
     ssl->bm_read_index = 0;
     ssl->next_state = HS_SERVER_HELLO;
     ssl->hs_status = SSL_NOT_OK;            /* not connected */
+    x509_free(ssl->x509_ctx);
 
     /* sit in a loop until it all looks good */
     while (ssl->hs_status != SSL_OK)
     {
         ret = basic_read(ssl, NULL);
         
         if (ret < SSL_OK)
         { 
             if (ret != SSL_ERROR_CONN_LOST)
             {
                 /* let the server know we are dying and why */
                 if (send_alert(ssl, ret))
                 {
                     /* something nasty happened, so get rid of it */
                     kill_ssl_session(ssl->ssl_ctx->ssl_sessions, ssl);
                 }
             }
 
             break;
         }
     }
 
     ssl->hs_status = ret;            /* connected? */
     return ret;
 }
 
 /*
  * Send the initial client hello.
  */
 static int send_client_hello(SSL *ssl)
 {
     uint8_t *buf = ssl->bm_data;
     time_t tm = time(NULL);
     uint8_t *tm_ptr = &buf[6]; /* time will go here */
     int i, offset;
 
     buf[0] = HS_CLIENT_HELLO;
     buf[1] = 0;
     buf[2] = 0;
     /* byte 3 is calculated later */
     buf[4] = 0x03;
     buf[5] = 0x01;
 
     /* client random value - spec says that 1st 4 bytes are big endian time */
     *tm_ptr++ = (uint8_t)(((long)tm & 0xff000000) >> 24);
     *tm_ptr++ = (uint8_t)(((long)tm & 0x00ff0000) >> 16);
     *tm_ptr++ = (uint8_t)(((long)tm & 0x0000ff00) >> 8);
     *tm_ptr++ = (uint8_t)(((long)tm & 0x000000ff));
     get_random(SSL_RANDOM_SIZE-4, &buf[10]);
     memcpy(ssl->dc->client_random, &buf[6], SSL_RANDOM_SIZE);
     offset = 6 + SSL_RANDOM_SIZE;
 
     /* give session resumption a go */
     if (IS_SET_SSL_FLAG(SSL_SESSION_RESUME))    /* set initially by user */
     {
         buf[offset++] = ssl->sess_id_size;
         memcpy(&buf[offset], ssl->session_id, ssl->sess_id_size);
         offset += ssl->sess_id_size;
         CLR_SSL_FLAG(SSL_SESSION_RESUME);       /* clear so we can set later */
     }
     else
     {
         /* no session id - because no session resumption just yet */
         buf[offset++] = 0;
     }
 
     buf[offset++] = 0;              /* number of ciphers */
     buf[offset++] = NUM_PROTOCOLS*2;/* number of ciphers */
 
     /* put all our supported protocols in our request */
     for (i = 0; i < NUM_PROTOCOLS; i++)
     {
         buf[offset++] = 0;          /* cipher we are using */
         buf[offset++] = ssl_prot_prefs[i];
     }
 
     buf[offset++] = 1;              /* no compression */
     buf[offset++] = 0;
     buf[3] = offset - 4;            /* handshake size */
 
     return send_packet(ssl, PT_HANDSHAKE_PROTOCOL, NULL, offset);
 }
 
 /*
  * Process the server hello.
  */
 static int process_server_hello(SSL *ssl)
 {
     uint8_t *buf = ssl->bm_data;
     int pkt_size = ssl->bm_index;
     int version = (buf[4] << 4) + buf[5];
     int num_sessions = ssl->ssl_ctx->num_sessions;
     uint8_t sess_id_size;
     int offset, ret = SSL_OK;
 
     /* check that we are talking to a TLSv1 server */
     if (version != 0x31)
         return SSL_ERROR_INVALID_VERSION;
 
     /* get the server random value */
     memcpy(ssl->dc->server_random, &buf[6], SSL_RANDOM_SIZE);
     offset = 6 + SSL_RANDOM_SIZE; /* skip of session id size */
     sess_id_size = buf[offset++];
 
     if (num_sessions)
     {
         ssl->session = ssl_session_update(num_sessions,
                 ssl->ssl_ctx->ssl_sessions, ssl, &buf[offset]);
         memcpy(ssl->session->session_id, &buf[offset], sess_id_size);
 
         /* pad the rest with 0's */
         if (sess_id_size < SSL_SESSION_ID_SIZE)
         {
             memset(&ssl->session->session_id[sess_id_size], 0,
                 SSL_SESSION_ID_SIZE-sess_id_size);
         }
     }
 
     memcpy(ssl->session_id, &buf[offset], sess_id_size);
     ssl->sess_id_size = sess_id_size;
     offset += sess_id_size;
 
     /* get the real cipher we are using */
     ssl->cipher = buf[++offset];
     ssl->next_state = IS_SET_SSL_FLAG(SSL_SESSION_RESUME) ? 
                                         HS_FINISHED : HS_CERTIFICATE;
 
     offset++;   // skip the compr
     PARANOIA_CHECK(pkt_size, offset);
     ssl->dc->bm_proc_index = offset+1; 
 
 error:
     return ret;
 }
 
 /**
  * Process the server hello done message.
  */
 static int process_server_hello_done(SSL *ssl)
 {
     ssl->next_state = HS_FINISHED;
     return SSL_OK;
 }
 
 /*
  * Send a client key exchange message.
  */
 static int send_client_key_xchg(SSL *ssl)
 {
     uint8_t *buf = ssl->bm_data;
     uint8_t premaster_secret[SSL_SECRET_SIZE];
     int enc_secret_size = -1;
 
     buf[0] = HS_CLIENT_KEY_XCHG;
     buf[1] = 0;
 
     premaster_secret[0] = 0x03; /* encode the version number */
     premaster_secret[1] = 0x01;
     get_random(SSL_SECRET_SIZE-2, &premaster_secret[2]);
     DISPLAY_RSA(ssl, ssl->x509_ctx->rsa_ctx);
 
     /* rsa_ctx->bi_ctx is not thread-safe */
     SSL_CTX_LOCK(ssl->ssl_ctx->mutex);
     enc_secret_size = RSA_encrypt(ssl->x509_ctx->rsa_ctx, premaster_secret,
             SSL_SECRET_SIZE, &buf[6], 0);
     SSL_CTX_UNLOCK(ssl->ssl_ctx->mutex);
 
     buf[2] = (enc_secret_size + 2) >> 8;
     buf[3] = (enc_secret_size + 2) & 0xff;
     buf[4] = enc_secret_size >> 8;
     buf[5] = enc_secret_size & 0xff;
 
     generate_master_secret(ssl, premaster_secret);
     return send_packet(ssl, PT_HANDSHAKE_PROTOCOL, NULL, enc_secret_size+6);
 }
 
 /*
  * Process the certificate request.
  */
 static int process_cert_req(SSL *ssl)
 {
     uint8_t *buf = &ssl->bm_data[ssl->dc->bm_proc_index];
     int ret = SSL_OK;
     int offset = (buf[2] << 4) + buf[3];
     int pkt_size = ssl->bm_index;
 
     /* don't do any processing - we will send back an RSA certificate anyway */
     ssl->next_state = HS_SERVER_HELLO_DONE;
     SET_SSL_FLAG(SSL_HAS_CERT_REQ);
     ssl->dc->bm_proc_index += offset;
     PARANOIA_CHECK(pkt_size, offset);
 error:
     return ret;
 }
 
 /*
  * Send a certificate verify message.
  */
 static int send_cert_verify(SSL *ssl)
 {
     uint8_t *buf = ssl->bm_data;
     uint8_t dgst[MD5_SIZE+SHA1_SIZE];
     RSA_CTX *rsa_ctx = ssl->ssl_ctx->rsa_ctx;
     int n = 0, ret;
 
     DISPLAY_RSA(ssl, rsa_ctx);
 
     buf[0] = HS_CERT_VERIFY;
     buf[1] = 0;
 
     finished_digest(ssl, NULL, dgst);   /* calculate the digest */
 
     /* rsa_ctx->bi_ctx is not thread-safe */
     if (rsa_ctx)
     {
         SSL_CTX_LOCK(ssl->ssl_ctx->mutex);
         n = RSA_encrypt(rsa_ctx, dgst, sizeof(dgst), &buf[6], 1);
         SSL_CTX_UNLOCK(ssl->ssl_ctx->mutex);
 
         if (n == 0)
         {
             ret = SSL_ERROR_INVALID_KEY;
             goto error;
         }
     }
     
     buf[4] = n >> 8;        /* add the RSA size (not officially documented) */
     buf[5] = n & 0xff;
     n += 2;
     buf[2] = n >> 8;
     buf[3] = n & 0xff;
     ret = send_packet(ssl, PT_HANDSHAKE_PROTOCOL, NULL, n+4);
 
 error:
     return ret;
 }
 
 #endif      /* CONFIG_SSL_ENABLE_CLIENT */
